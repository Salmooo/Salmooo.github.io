<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="计算机系统学习总结">
<title>计算机系统学习总结</title>

<link rel='canonical' href='https://Salmooo.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/'>

<link rel="stylesheet" href="/scss/style.min.b9c8156d464c343bdacaf14a871581fb94cbbdb9dd5cbce4ba017361187cc930.css"><meta property='og:title' content="计算机系统学习总结">
<meta property='og:description' content="计算机系统学习总结">
<meta property='og:url' content='https://Salmooo.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/'>
<meta property='og:site_name' content='SalmoneX Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='Computer system' /><meta property='article:tag' content='408' /><meta property='article:published_time' content='2019-10-16T19:32:27&#43;08:00'/><meta property='article:modified_time' content='2019-10-16T19:32:27&#43;08:00'/>
<meta name="twitter:title" content="计算机系统学习总结">
<meta name="twitter:description" content="计算机系统学习总结">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu13739649187745961479.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">SalmoneX Blog</a></h1>
            <h2 class="site-description">Record the road to rebirth</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/Salmooo'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="https://Salmooo.github.io/" selected>English</option>
                                
                                    <option value="https://Salmooo.github.io/zh-cn/" >中文</option>
                                
                                    <option value="https://Salmooo.github.io/ar/" >عربي</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>Dark Mode</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">Table of contents</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#11-操作系统的特性">1.1 操作系统的特性</a></li>
    <li><a href="#12-操作系统的主要功能">1.2 操作系统的主要功能</a></li>
    <li><a href="#13-用户态和内核态">1.3 用户态和内核态</a></li>
  </ol>

  <ol>
    <li><a href="#21-线程进程协程">2.1 线程，进程，协程</a>
      <ol>
        <li><a href="#多线程"><strong>多线程</strong></a></li>
        <li><a href="#q1-进程中的一个线程崩溃之后所有线程都会崩溃吗">Q1. <strong>进程中的一个线程崩溃之后所有线程都会崩溃吗？</strong></a></li>
        <li><a href="#协程和线程">协程和线程</a></li>
      </ol>
    </li>
    <li><a href="#22-进程有哪些状态转换条件是什么">2.2 进程有哪些状态，转换条件是什么？</a></li>
    <li><a href="#23-进程间通信">2.3 进程间通信</a>
      <ol>
        <li><a href="#管道pipe">管道(pipe)</a></li>
        <li><a href="#消息队列messagequeue">消息队列(messagequeue)</a></li>
        <li><a href="#共享内存shared-memory">共享内存(shared memory)</a></li>
        <li><a href="#信号量semaphore">信号量(semaphore)</a></li>
        <li><a href="#信号-sinal">信号 (sinal)</a></li>
        <li><a href="#socket套接字">Socket(套接字)</a></li>
      </ol>
    </li>
    <li><a href="#24-进程间同步通信主要为了同步">2.4 进程间同步（通信主要为了同步）</a></li>
    <li><a href="#25-线程间同步和通信">2.5 线程间同步和通信</a>
      <ol>
        <li><a href="#1-临界区">1. 临界区</a></li>
        <li><a href="#2-互斥量">2. <strong>互斥量</strong></a></li>
        <li><a href="#哲学家进餐问题">哲学家进餐问题：</a></li>
        <li><a href="#3信号量">3.信号量</a></li>
        <li><a href="#4-信号">4. 信号</a></li>
        <li><a href="#5-读写锁">5. 读写锁</a></li>
        <li><a href="#6-条件变量condition">6. 条件变量(condition)</a></li>
        <li><a href="#7-事件"><strong>7. 事件</strong></a></li>
      </ol>
    </li>
    <li><a href="#27-线程的分类">2.7 线程的分类</a></li>
    <li><a href="#28-线程池">2.8 线程池</a></li>
    <li><a href="#29-进程调度">2.9 进程调度</a></li>
    <li><a href="#210-多线程冲突了怎么办">2.10 多线程冲突了怎么办</a></li>
  </ol>

  <ol>
    <li><a href="#31-逻辑地址线性地址和物理地址的区别">3.1 逻辑地址、线性地址和物理地址的区别？</a></li>
    <li><a href="#32-寻址方式有哪些">3.2 寻址方式有哪些？</a></li>
    <li><a href="#33-什么是虚拟内存">3.3 什么是虚拟内存？</a>
      <ol>
        <li><a href="#331-虚拟内存作用">3.3.1 虚拟内存作用</a></li>
      </ol>
    </li>
    <li><a href="#34-什么是交换空间">3.4 什么是交换空间？</a></li>
    <li><a href="#35-什么是分页">3.5 什么是分页？</a></li>
    <li><a href="#36-什么是分段">3.6 什么是分段？</a></li>
    <li><a href="#37-分页分段的区别是什么">3.7 分页分段的区别是什么？</a></li>
    <li><a href="#38-有哪些页面置换算法">3.8 有哪些页面置换算法？</a></li>
    <li><a href="#39-段式内存管理">3.9 段⻚式内存管理</a></li>
    <li><a href="#310-cache">3.10 Cache</a></li>
    <li><a href="#311-linux内存分布">3.11 Linux内存分布</a></li>
    <li><a href="#312-malloc-是如何分配内存的">3.12 malloc 是如何分配内存的？</a></li>
    <li><a href="#313-malloc-分配的是物理内存吗">3.13 malloc() 分配的是物理内存吗？</a></li>
    <li><a href="#314-为什么不全部使用-mmap-来分配内存">3.14 为什么不全部使用 mmap 来分配内存？</a></li>
    <li><a href="#315-free-函数只传入一个内存地址为什么能知道要释放多大的内存">3.15 free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？</a></li>
  </ol>

  <ol>
    <li>
      <ol>
        <li><a href="#软中断和硬中断">软中断和硬中断</a></li>
      </ol>
    </li>
    <li><a href="#41-中断的处理过程">4.1 中断的处理过程</a>
      <ol>
        <li><a href="#中断请求">中断请求</a></li>
        <li><a href="#中断响应">中断响应</a></li>
        <li><a href="#中断服务处理阶段">中断服务处理阶段</a></li>
      </ol>
    </li>
    <li><a href="#42-中断和轮询有什么区别">4.2 中断和轮询有什么区别？</a></li>
  </ol>

  <ol>
    <li><a href="#51-磁盘调度">5.1 磁盘调度</a></li>
  </ol>

  <ol>
    <li><a href="#61-软硬链接">6.1 软硬链接</a></li>
    <li><a href="#62-直接io与非直接io">6.2 直接io与非直接io</a></li>
    <li><a href="#63-同步io异步io">6.3. 同步IO，异步IO</a></li>
    <li><a href="#64-如何服务更多的用户">6.4 如何服务更多的用户</a></li>
    <li><a href="#65-selectpollepoll的原理区别">6.5 select，poll，epoll的原理、区别</a>
      <ol>
        <li><a href="#select">select:</a></li>
        <li><a href="#poll">Poll</a></li>
        <li><a href="#epoll"><strong>epoll</strong></a></li>
      </ol>
    </li>
    <li><a href="#66-dma和零拷贝">6.6 DMA和零拷贝</a>
      <ol>
        <li><a href="#如何实现零拷贝">如何实现零拷贝？</a></li>
      </ol>
    </li>
    <li><a href="#67-大文件传输">6.7 大文件传输</a></li>
    <li><a href="#68-socket模型">6.8 Socket模型</a></li>
  </ol>

  <ol>
    <li><a href="#71-键盘敲入字母时期间发生了什么">7.1 键盘敲入字母时，期间发生了什么？</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/computer-system/" >
                Computer System
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">计算机系统学习总结</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            计算机系统学习总结
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Oct 16, 2019</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    11 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="1-总体概念">1. 总体概念
</h1><h2 id="11-操作系统的特性">1.1 操作系统的特性
</h2><p>四个特性：<strong>并发、共享、虚拟、异步。</strong></p>
<ul>
<li>并发：同一段时间内(时间片轮转算法)多个程序执行。程序并发性体现在两个方面： <strong>用户程序与用户程序之间</strong>的并发执行。 用户程序与操作系统程序之间的并发。</li>
<li>共享：系统中的资源可以被内存中多个并发执行的<strong>进线程共同使用</strong>。</li>
<li>虚拟：通过<strong>时分复用</strong>（虚拟处理机、虚拟设备）以及<strong>空分复用</strong>（如虚拟内存，虚拟磁盘）技术实现<strong>把一个物理实体虚拟为多个</strong>。</li>
<li>异步：系统中的<strong>进程是以走走停停的方式</strong>执行的，<strong>且以一种不可预知的速度推进</strong>。（同步就是<strong>实时处理</strong>，比如打电话，异步就是<strong>分时处理</strong>，比如<strong>发短信</strong>）</li>
</ul>
<h2 id="12-操作系统的主要功能">1.2 操作系统的主要功能
</h2><p>操作系统的本质是<strong>对资源的管理</strong>。包括了：</p>
<ul>
<li><strong>处理器管理</strong>：以进程为单位分配资源，</li>
<li><strong>存储器管理</strong>：也叫内存管理</li>
<li><strong>设备管理</strong>：完成所有的IO请求</li>
<li><strong>文件管理</strong>：包括磁盘存储空间管理，文件读写管理等等</li>
</ul>
<h2 id="13-用户态和内核态">1.3 用户态和内核态
</h2><p>从整体上讲，操作系统一般可分为**内核（kernel）<strong>和</strong>外壳（shell）**两大部分。</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218111032.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>内核态与用户态是操作系统的两种运行级别,</p>
<p>用户态：<strong>当进程在执行用户自己的代码时，则称其处于用户态</strong>，这时<strong>cpu访问资源有限</strong>，<strong>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序</strong>。</p>
<p>内核态：<strong>当一个任务(进程)执行系统调用而陷入内核代码中执行时，我们就称进程处于内核状态，这时cpu可以访问计算机的任何资源</strong>。</p>
<p>当程序运行在0级特权级上时，就可以称之为运行在内核态，CPU将指令分为<strong>特权指令和非特权指令，</strong></p>
<p>对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。比如清内存、设置时钟。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。</p>
<p>当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；</p>
<p>两种状态的主要区别</p>
<blockquote>
<p>处于用户态执行时，进程所能访问的内存空间和对象<strong>受到限制</strong>，<strong>其所处于占有的处理机是可被抢占的</strong> ；</p>
<p>而处于内核态执行中的进程，则能<strong>访问所有的内存空间和对象</strong>，且<strong>所占有的处理机是不允许被抢占的</strong>。</p>
</blockquote>
<p>用户态切换到内核态有三种情况：<strong>主动，被动，被迫</strong></p>
<ul>
<li><strong>系统调用</strong>：用户态进程主动要求切换到内核态申请使用操作系统提供的服务程序完成工作的一种方式，<strong>fork()实际上就是执行了一个创建新进程的系统调用。（主动）</strong></li>
<li><strong>异常</strong>：当前运行进程切换到<strong>处理此异常</strong>的<strong>内核相关程序 （被迫）</strong></li>
<li><strong>外围设备中断</strong>：当外围设备完成用户请求的操作后，<strong>会向CPU发出相应的中断信号</strong>，这时CPU会暂停执行下一条即将要执行的指令转而去<strong>执行与中断信号对应的处理程序</strong>。  <strong>如果先前执行的指令是用户态下的程序</strong>，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。<strong>（被动）</strong></li>
</ul>
<p>从触发方式上看，可以认为存在前述3种不同的类型。</p>
<p>但是从最终实际完成由用户态到内核态的切换操作上来说，<strong>涉及的关键步骤是完全一致的</strong>，没有任何区别。</p>
<p>都相当于执行了一个<strong>中断响应</strong>的过程，因为系统调用实际上最终是<strong>中断机制实现</strong>的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析。</p>
<p>涉及到由用户态切换到内核态的步骤：
需要注意的是，内核态堆栈仅用于内核例程，Linux内核另外为中断提供了单独的硬中断栈和软中断栈
[1] 从当前进程的描述符中提取其内核栈的ss0及esp0信息。（ss0段选择子，用于指示内核堆栈所在的段描述符，esp堆栈是一个32位寄存器，存储了内核模式下的堆栈顶部地址指针)
[2] 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。
[3] 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</p>
<p>（因为内核控制路径使用很少的栈空间，所以只需要几千个字节的内核态堆栈。 需要注意的是，内核态堆栈仅用于内核例程，<strong>Linux内核另外为中断提供了单独的硬中断栈和软中断栈）</strong></p>
<p><strong>寄存器常见缩写：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1. PC - Program Counter（程序计数器）
</span></span><span class="line"><span class="cl">2. SP - Stack Pointer（栈指针）
</span></span><span class="line"><span class="cl">3. IR - Instruction Register（指令寄存器）
</span></span><span class="line"><span class="cl">4. PSW - Program Status Word（程序状态字）
</span></span><span class="line"><span class="cl">5. ACC - Accumulator（累加器）
</span></span><span class="line"><span class="cl">6. R0, R1, R2, ... - General Purpose Registers（通用寄存器）
</span></span><span class="line"><span class="cl">7. MAR - Memory Address Register（存储器地址寄存器）
</span></span><span class="line"><span class="cl">8. MDR - Memory Data Register（存储器数据寄存器）
</span></span><span class="line"><span class="cl">9. MSR - Machine Status Register（机器状态寄存器）
</span></span><span class="line"><span class="cl">10. SR - Status Register（状态寄存器）
</span></span><span class="line"><span class="cl">11. CR - Control Register（控制寄存器）
</span></span><span class="line"><span class="cl">12. EFLAGS - Extended Flags Register（扩展标志寄存器）
</span></span><span class="line"><span class="cl">13. FLAGS - Flags Register（标志寄存器）
</span></span><span class="line"><span class="cl">14. XMM - Extended Multimedia Register（扩展多媒体寄存器）
</span></span><span class="line"><span class="cl">15. FPU - Floating Point Unit（浮点运算单元）
</span></span><span class="line"><span class="cl">16. MMX - Multimedia Extensions（多媒体扩展寄存器）
</span></span><span class="line"><span class="cl">17. GP - Global Pointer（全局指针）
</span></span><span class="line"><span class="cl">18. BP - Base Pointer（基址指针）
</span></span><span class="line"><span class="cl">19. SP - Stack Pointer（栈指针）
</span></span><span class="line"><span class="cl">20. IP - Instruction Pointer（指令指针）
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="2-线程与进程">2. 线程与进程
</h1><h2 id="21-线程进程协程">2.1 线程，进程，协程
</h2><p><strong>进程是资源分配的基本单位</strong>，它<strong>是程序执行时的一个实例</strong>，在程序运行时创建；</p>
<p>线程是<strong>程序执行的最小单位</strong>，是<strong>进程的子任务，是进程的一个执行流，一般来说一个进程由多个线程组成的。</strong></p>
<p>具体来说：</p>
<p><strong>定义，资源隔离，创建销毁开销，切换开销通信和同步，并发性和并行性，故障影响，使用场景</strong></p>
<ul>
<li><strong>进程是操作系统分配资源的单位</strong>，而<strong>线程是进程的一个实体，是CPU调度和分派的基本单位</strong>。</li>
<li><strong>线程没有独立的内存单元，只拥有一点在运行中必不可少的资源，如寄存器和运行栈，不能够独立执行，必须依存在进程中。</strong></li>
<li>执行过程：<strong>每个独立的进程有程序运行的入口</strong>、顺序执行序列和程序出口。<strong>但是线程不能独立执</strong>行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行。</li>
<li><strong>资源开销</strong>：每个进程都有<strong>独立的代码和数据空间</strong>（程序上下文），程序之间的<strong>切换会有较大的开销</strong>；</li>
<li>线程可以看做轻量级的进程，<strong>同一类线程共享代码和数据空间</strong>，每个<strong>线程都有自己独立的运行栈和程序计数器（PC）</strong>，<strong>线程之间切换的开销小</strong>。</li>
<li>包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li>
<li>影响关系：<strong>一个进程崩溃后，在保护模式下不会对其他进程产生影响</strong>，但是一个线程崩溃整个进程都死掉。所以<strong>多进程要比多线程健壮</strong>。</li>
</ul>
<p>对于操作系统来说，<strong>一个任务就是一个进程(Process)</strong>，比如使用Word。</p>
<p>而一个进程可能不只干一件事（<strong>比如word既要打字又要检查拼写</strong>），这种<strong>进程内的多个子任务就是线程</strong>（Thread），<strong>进程</strong>是程序的一次执行过程，<strong>是系统运行程序的基本单位</strong>，因此进程是动态的。</p>
<p>系统运行一个程序即是<strong>一个进程从创建，运行到消亡的过程</strong>。简单来说，<strong>一个进程就是一个执行中的程</strong>序，它在计算机中一个指令接着一个指令地执行着，同时，<strong>每个进程还占有某些系统资源</strong>如<strong>CPU时间，内存空间，文件，文件，输入输出设备的使用权</strong>等等。</p>
<p>换句话说，<strong>当程序在执行时，将会被操作系统载入内存中</strong>。</p>
<p>Q: <strong>一个进程最多可以创建多少个线程？</strong></p>
<ul>
<li><strong>进程的虚拟内存空间上限</strong>，<strong>因为创建一个线程，操作系统需要为其分配一个栈空间</strong>，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多。</li>
<li><strong>系统参数限制</strong>，虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有<strong>系统级别的参数来控制整个系统的最大线程个数</strong>。</li>
</ul>
<h3 id="多线程"><strong>多线程</strong>
</h3><p>举个例子，假设要编写一个视频播放器软件，那么该软件功能的核心模块有三个：</p>
<ul>
<li><strong>从视频文件当中读取数据</strong>；</li>
<li>对读取<strong>的数据进行解压缩</strong>；</li>
<li>把解压缩<strong>后的视频数据播放出来</strong>；</li>
<li><strong>播放出来的画面和声音会不连贯，因为当 CPU 能力不够强的时候，<code>Read</code> 的时候可能进程就等在这了，这样就会导致等半天才进行数据解压和播放；</strong></li>
<li>各个函数之间<strong>不是并发执行</strong>，影响资源的使用效率；</li>
</ul>
<p><strong>Q: 多线程的好处:</strong></p>
<p><strong>并发执行，资源共享，核心利用，多任务场景，代码模块化，提高响应性</strong></p>
<p>通俗地讲例子：</p>
<p>1.使用线程可以把占<strong>据时间长的程序中的任务放到后台去处理</strong></p>
<p>2.用户界面更加吸引人,这样<strong>比如用户点击了一个按钮去触发某件事件的处理,可以弹出一个进度条来显示处理的进度</strong></p>
<p>3.<strong>程序的运行效率可能会提高</strong></p>
<p>4.在一些<strong>等待的任务实现上如用户输入,文件读取和网络收发数据等</strong>, 线程就比较有用了。</p>
<p>线程主要优点：</p>
<ul>
<li>一个进程中可以同时存在多个线程；</li>
<li>各个线程之间可以<strong>并发执行</strong>；</li>
<li>各个线程之间可以<strong>共享地址空间和文件等资源</strong>；</li>
</ul>
<p><strong>Q: 多线程的缺点:</strong></p>
<p>竞态条件，死锁和活锁，通信复杂，调试困难，性能下降，不确定性</p>
<ol>
<li>如果<strong>有大量的线程,大量的上下文切换会影响性能,因为操作系统需要在它们之间切换</strong>.</li>
<li>更多的线程需要<strong>更多的内存空间</strong></li>
<li>线程<strong>中止需要考虑对程序运行的影响.</strong> 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C/C++ 语言，Java语言中的线程奔溃不会造成进程崩溃）</li>
<li>通常块模型数据是在多个线程间共享的, 需要防止<strong>线程死锁情况</strong>的发生</li>
</ol>
<h3 id="q1-进程中的一个线程崩溃之后所有线程都会崩溃吗">Q1. <strong>进程中的一个线程崩溃之后所有线程都会崩溃吗？</strong>
</h3><p>这个不是必定发生的，假设一个进程启动了a,b,c三个线程，只要这三个线程之间的其中一个在运行过程中触发了<strong>unix的信号，比如除0异常，违规访问内存触发段错误等等，都会使得os向进程发送特定的信号</strong>，<strong>进程默认的行为是在接收到这些信号的时候退出</strong>，<strong>表象就是你所说的一个线程奔溃导致其他线程奔溃了</strong>。</p>
<p>但是如果<strong>a线程的奔溃没有触发操作系统向进程发送信号或者在进程中已经提前注册了对应信号的回调函数</strong>(此时收到信号进程不会按默认行为退出而且执行预设的回调函数)，那么<strong>其他两个线程还是能正常地运行。</strong></p>
<p><strong>大部分情况下，其他线程并不会自己崩溃，而是操作系统检测到异常，会kill掉进程，其他线程就一起被干掉了。</strong></p>
<p><strong>小部分情况下</strong>，<strong>一个线程出错，破坏了进程中其他线程的内存，导致其他线程出现严重错误，被操作系统检测到，然后连同进程一起干掉</strong>。</p>
<p>进程是由内核管理和调度的，所以进程的切换只能发生在内核态。</p>
<p>进程上下文切换开销</p>
<p>Q: 为什么物理内存只有 2G，进程的虚拟内存却可以使用 25T 呢？</p>
<p>因为<strong>虚拟内存并不是全部都映射到物理内存的</strong>，</p>
<p><strong>程序是有局部性的特性，也就是某一个时间只会执行部分代码，所以只需要映射这部分程序就好</strong></p>
<ul>
<li>32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。</li>
<li>64 位系统，用户态的虚拟空间大到有 128T，<strong>理论上不会受虚拟内存大小的限制</strong>，<strong>而会受系统的参数或性能限制</strong>。</li>
</ul>
<p><strong>总结：</strong></p>
<ol>
<li><strong>一个程序至少有一个进程, 一个进程至少有一个线程</strong>。hh</li>
<li>进程在执行过程中<strong>拥有独立的内存单元</strong>，而<strong>多个线程共享内存。同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核</strong></li>
<li><strong>引入线程的好处：</strong> 线程快！<strong>创建、终止、切换</strong>都很快！<strong>虽然线程拥有单独的程序运行入口，出口，但不能独立执行</strong>。</li>
</ol>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b7d61d94-75ff-40c5-b659-fe1ba3852f98/Untitled.png"
	
	
	
	loading="lazy"
	
		alt="Untitled"
	
	
></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/48e7525f-9f6b-4737-bb87-380664d2d6c9/Untitled.png"
	
	
	
	loading="lazy"
	
		alt="Untitled"
	
	
></p>
<p>(1)用户级上下文: <strong>正文、数据、用户堆栈以及共享存储区</strong>；</p>
<p>(2)寄存器上下文: 通用寄存器、<strong>程序寄存器(IP)、处理器状态寄存器(EFLAGS)</strong>、<strong>栈指针(ESP)</strong>；</p>
<p>(3)系统级上下文: <strong>进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈</strong>。</p>
<h3 id="协程和线程">协程和线程
</h3><ol>
<li>
<p>一个线程可以多个协程，一个进程也可以单独拥有多个协程。</p>
</li>
<li>
<p>线程进程都是同步机制，而<strong>协程则是异步</strong>。</p>
</li>
<li>
<p>协程能<strong>保留上一次调用时的状态，每次过程重入时</strong>，就相当于进入上一次调用的状态。</p>
</li>
<li>
<p><strong>线程是抢占式，而协程是非抢占式的</strong>，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其<strong>实只有一个协程拥有运行权</strong>，相当于单线程的能力。</p>
</li>
<li>
<p>协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, <strong>协程需要线程来承载运行, 线程是协程的资源</strong>, 但<strong>协程不会直接使用线程, 协程直接利用的是执行器(Interceptor),</strong> 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。</p>
</li>
<li>
<p>线程是协程的资源。<strong>协程通过Interceptor来间接使用线程这个资源。</strong></p>
</li>
</ol>
<h2 id="22-进程有哪些状态转换条件是什么">2.2 进程有哪些状态，转换条件是什么？
</h2><p><strong>就绪状态</strong>：进程获得了除CPU之外的一切所需资源</p>
<p><strong>运行状态</strong>：一个CPU的一个核只能有一个进程处于运行状态。</p>
<p><strong>阻塞状态</strong>，又称等待状态：进程需要其他资源或正在等待某一事件发生而暂停运行。如<strong>等待某资源为可用</strong>（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218102010.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><strong>注意区别就绪状态和等待状态：</strong></p>
<p><strong>就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；<strong>而</strong>等待状态是指进程需要其他资源（除了处理机）或等待某一事件。</strong></p>
<p><strong>Sleep()函数和wait()函数的区别</strong></p>
<p>（1）属于不同的两个类，<strong>sleep()方法是线程类（Thread）的静态方法，wait()方法是Object类里的方法</strong>。</p>
<p>（2）<strong>sleep()方法不会释放锁</strong>，<strong>wait()方法释放对象锁</strong>。</p>
<p>（3）<strong>sleep()方法可以在任何地方使用</strong>，wait()方法则只能在<strong>同步方法或同步块</strong>中使用。</p>
<p>（4）<strong>sleep()使线程进入阻塞状态（线程睡眠）</strong>，wait()方法使线程进入等待队列（线程挂起），也就是阻塞类别不同。</p>
<p>join()方法： join()方法使调用该方法的线程在此之前执行完毕，<strong>也就是等待该方法的线程执行完毕后再往下继续执行</strong>。注意该方法也需要捕捉异常。</p>
<p>yield()方法:该方法与sleep()类似，都是可以让当前正在运行的线程暂停，<strong>区别在于yield()方法不会阻塞该线程，它只是将线程转换成就绪状态</strong>，让系统的调度器重新调度一次，<strong>并且yield()方法只能让优先级相同或许更高的线程有执行的机会</strong>。</p>
<h2 id="23-进程间通信">2.3 进程间通信
</h2><p>IPC(Inter process communication)问题，主要是指<strong>进程间交换数据的方式</strong>。</p>
<p><strong>进程是相互独立的，<strong>并</strong>不需要条件变量、互斥锁这些机制，要锁也是文件锁这种大锁</strong>。</p>
<p>而线程需要互斥锁的原因是：<strong>线程之间的资源室共享的，需要程序员来完成变量级别的同步。</strong></p>
<p>进程间通信分为<strong>低级通信</strong>和<strong>高级通信</strong>。</p>
<ul>
<li>低级通信：<strong>信号量</strong></li>
<li>高级通信：
<ul>
<li><strong>管道</strong></li>
<li><strong>消息队列</strong></li>
<li><strong>共享内存</strong></li>
</ul>
</li>
<li>信号 套接字</li>
</ul>
<h3 id="管道pipe">管道(pipe)
</h3><p>管道是一种<strong>半双工的通信方式，数据只能单向流动</strong>，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<p><strong>管道</strong>是指用于<strong>连接一个读进程和一个写进程的一个共享文件</strong>，<strong>又名pipe文件</strong>，以<strong>字符流形式</strong>将数据写入文件。</p>
<p>管道分为<strong>无名管道</strong>和<strong>有名管道</strong>：匿名管道<strong>就是内核⾥⾯的⼀串缓存</strong>。从管道的⼀段写⼊的数据，实际上是缓存在内核中的，另⼀端读取，也就是从内核中读取这段数据。另外，<strong>管道传输的数据是⽆格式的流且⼤⼩受限</strong>。</p>
<p><strong>对于匿名管道，它的通信范围是存在⽗⼦关系的进程</strong>。因为管道没有实体，也就是没有管道⽂件，只能通过 fork 来复制⽗进程 fd ⽂件描述符，来达到通信的⽬的。</p>
<p>另外，<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了⼀个类型为管道的设备⽂件，在进程⾥只要使⽤这个设备⽂件，就可以相互通信。在 shell ⾥⾯执⾏ A | B 命令的时候，A 进程和 B 进程都是 shell 创建出来的⼦进程，<strong>A 和 B 之间不存在⽗⼦关系，它俩的⽗进程都是 shell。</strong></p>
<ul>
<li>匿名管道是<strong>半双工的通信方式</strong>，数据<strong>只能单向流动</strong>，只能在父子进程中流通；</li>
<li>有名管道也是半双工，<strong>但是</strong>它<strong>允许无亲缘关系进程间通信</strong>。</li>
</ul>
<p><strong>通信⽅式是效率低的，因此管道不适合进程间频繁地交换数据。</strong></p>
<p>所谓的管道，就是<strong>内核⾥⾯的⼀串缓存</strong>。 <strong>读写效率低，因此管道不适合进程间频繁地交换数据。</strong></p>
<p><strong>创建的⼦进程会复制⽗进程的⽂件描述符。</strong></p>
<p><strong>对于匿名管道，它的通信范围是存在⽗⼦关系的进程</strong>，</p>
<p><strong>对于命名管道，它可以在不相关的进程间也能相互通信。</strong></p>
<p>不管是匿名管道还是命名管道，进程写⼊的数据都是缓存在内核中，另⼀个进程读取数据时候⾃然也是从内核中获取，同时通信数据都<strong>遵循先进先出原则</strong>。</p>
<h3 id="消息队列messagequeue">消息队列(messagequeue)
</h3><p><strong>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识</strong>，消息体是⽤户⾃定义的数据类型。</p>
<p><strong>消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</strong></p>
<p><strong>消息队列</strong>指的是<strong>进程间的数据交换是以格式化的消息(Message)为单位的</strong>，再由消息组成的链表，形成队列。</p>
<p><strong>消息队列是保存在内核中的消息链表</strong></p>
<p><strong>⼀：通信不及时</strong></p>
<p><strong>⼆：消息也有⼤⼩限制</strong>，这同样也是消息队列通信不⾜的点，</p>
<p><strong>三：消息队列通信过程中，存在⽤户态与内核态之间的数据拷⻉开销</strong>。</p>
<p><strong>消息队列不适合⽐较⼤数据的传输</strong>，因为在内核中每个消息体都有⼀个<strong>最⼤⻓度的限制</strong>，同时所有队列所包含的全部消息体的总⻓度也是有上限。</p>
<h3 id="共享内存shared-memory">共享内存(shared memory)
</h3><p>共享内存的机制，就是<strong>拿出⼀块虚拟地址空间来</strong>，<strong>映射到相同的物理内存中</strong>，这段共享内存<strong>由一个进程创建，但多个进程都可以访问</strong>。</p>
<p><strong>共享内存是最快的 IPC 方式</strong>，它是针对其他进程间通信方式运行效率低而专门设计的。</p>
<p>⽤了共享内存通信⽅式，带来新的问题，那就是<strong>如果多个进程同时修改同⼀个共享内存，很有可能就冲突</strong></p>
<p>例如两个进程都同时写⼀个地址，那先写的那个进程会发现内容被别⼈覆盖了。</p>
<p>它往往与其他通信机制，<strong>如信号量</strong>，配合使用，来实现<strong>进程间的同步和通信</strong>。</p>
<p><strong>共享内存</strong>指在通信的进程之间存在<strong>一块可直接访问的共享空间</strong>，通过对这片<strong>共享空间进行写/读操</strong>作实现进程之间的信息交换。</p>
<p>在对共享空间进行写/读操作时，需要使用同步互斥工具**（如 P操作、V操作）**，对共享空间的写/读进行控制。</p>
<p>P（S）：①将信号量S的值减1，即S=S-1；</p>
<p>②<strong>如果S&gt;=0，则该进程继续执行</strong>；<strong>否则该进程置为等待状态，排入等待队列</strong>。</p>
<p>V（S）：①将信号量S的值加1，即S=S+1；</p>
<p>②如果S&gt;0，则该进程继续执行；<strong>否则</strong>释放<strong>队列中第一个等待信号量的进程</strong>。</p>
<h3 id="信号量semaphore">信号量(semaphore)
</h3><p>信号量是一个计数器，<strong>可以用来控制多个进程对共享资源的访问</strong>。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p><strong>信号量</strong>是一个<strong>计数器</strong>，防止多个进程将资源拿光，防止某进程正在访问共享资源时，其他进程也访问该资源。</p>
<p>为了防⽌多进程竞争共享资源，⽽造成的数据错乱，所以需要保护机制，使得共享 的资源，在任意时刻只能被⼀个进程访问。正好，<strong>信号量</strong>就实现了这⼀保护机制。</p>
<p>⼀个是 <strong>P</strong> <strong>操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占⽤，进程需</p>
<p>阻塞等待；<strong>相减后如果信号量 &gt;= 0，则表明还有资源可使⽤</strong>，进程可正常继续执⾏。</p>
<p>另⼀个是 <strong>V</strong> <strong>操作</strong>，这个操作会把信号量加上 1，<strong>相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程</strong>，于是会将该进程唤醒运⾏；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</p>
<p><strong>信号初始化为 1 ，就代表着是互斥信号量</strong>，它可以<strong>保证共享内存在任何时刻只有⼀个进程在访问，这就很好的保护了共享内存。</strong></p>
<p><strong>信号初始化为 0 ，就代表着是同步信号量</strong>，它可以<strong>保证进程 A 应在进程 B 之前执⾏</strong></p>
<h3 id="信号-sinal">信号 (sinal)
</h3><p>**信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。**上⾯说的进程间通信，都是常规状态下的⼯作模式。</p>
<p>**对于异常情况下的⼯作模式，就需要⽤「信号」的⽅**式来通知进程。<strong>信号是进程间通信机制中唯⼀的异步通信机制，</strong></p>
<p><strong>1.执⾏默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上⾯列表中的 <strong>SIGTERM 信号，就是终⽌进程的意思</strong>。</p>
<p><strong>2.捕捉信号</strong>。我们可以为信号定义⼀个信号处理函数。当信号发⽣时，我们就执⾏相应的信号处理函数。</p>
<p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，<strong>就可以忽略该信号，不做任何处理</strong>。</p>
<p>有两个信号是应⽤进程⽆法捕捉和忽略的，即 <strong>SIGKILL 和 SEGSTOP</strong> ，它们⽤于在任何时候中断或结束某⼀进程。</p>
<h3 id="socket套接字">Socket(套接字)
</h3><p>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p>
<p>那要想<strong>跨⽹络与不同主机上的进程</strong>之间通信，就需要 <strong>Socket</strong> <strong>通信了。</strong></p>
<ul>
<li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li>
<li>服务端调用 <code>bind</code>，绑定 IP 地址和端口，协议;</li>
<li>服务端调用 <code>listen</code>，进行监听；</li>
<li>服务端调用 <code>accept</code>，等待客户端连接；</li>
<li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li>
<li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li>
<li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li>
<li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li>
</ul>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706201229857.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>image-20210706201229857</p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706202328078.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="24-进程间同步通信主要为了同步">2.4 进程间同步（通信主要为了同步）
</h2><p>多进程虽然提高了系统资源利用率和吞吐量，但是由于<strong>进程的异步性可能造成系统的混乱</strong>。<strong>进程同步</strong>的任务就是<strong>对多个相关进程在执行顺序上进行协调。</strong></p>
<p><strong>进程是相互独立的，所以进程间通信大多不需要锁，需要的锁也是文件锁之类的“大锁”，并不需要条件变量、互斥锁这些机制来同步</strong></p>
<h2 id="25-线程间同步和通信">2.5 线程间同步和通信
</h2><p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706202429960.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>由于线程间的资源可以共享，同步的方式就会更加细致：</p>
<ul>
<li><strong>互斥量</strong> 互斥与临界区很相似，但是使用时相对复杂一些（<strong>互斥量为内核对象）</strong>，<strong>不仅可以在同一应用程序的线程间实现同步，<strong>还可以在不同的进程间实现同步，从而实现资源的安全共享。 由于</strong>互斥量是内核对象</strong>，因此其可以进行进程间通信，同时还具有一个很好的特性，就是在进程间通信时完美的解决了“遗弃”问题</li>
<li><strong>信号量</strong>，只能用于一个资源的互斥访问，<strong>不能实现多个资源的多线程</strong>互斥问题。信号量的用法和互斥的用法很相似，不同的是它<strong>可以同一时刻允许多个线程访问同一个资源</strong>，PV操作。</li>
<li><strong>读写锁</strong>，可以<strong>被多个读者拥有</strong>，但是<strong>只能被一个写者拥有的锁</strong></li>
<li><strong>条件变量</strong>，线程 A 等待某个条件并挂起，<strong>直到线程 B 设置了这个条件</strong>，<strong>并通知条件变量，然后线程 A 被唤醒</strong></li>
<li><strong>原子操作PV：</strong></li>
<li><strong>通道：</strong></li>
<li>事件：</li>
</ul>
<h3 id="1-临界区">1. 临界区
</h3><p>每个进程中<strong>访问临界资源的那段程序称为临界区</strong>，<strong>一次仅允许一个进程使用的资源称为临界资源。</strong></p>
<p><strong>解决冲突的办法：</strong></p>
<ul>
<li>如果有若干进程要求进入空闲的临界区，<strong>一次仅允许一个进程进入</strong>，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</li>
<li>进入临界区的进程要在<strong>有限时间内退出</strong>。</li>
<li>如果进程<strong>不能进入自己的临界区，则应让出CPU</strong>，<strong>避免进程出现“忙等”现象。</strong></li>
</ul>
<p><strong><em>临界区</em>指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性</strong></p>
<p><strong>任何想进⼊临界区的线程，必须先执⾏加锁操作。</strong> <strong>若加锁操作顺利通过</strong>，则线程可进⼊临界区；</p>
<p><strong>在完成对临界资源的访问后再执⾏解锁操作</strong>，以释放该临界资源。</p>
<ul>
<li><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</li>
<li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</li>
</ul>
<p>当获取不到锁时，<strong>线程就会⼀直 wile 循环</strong>，不做任何事情，所以就被称为**「忙等待锁」，也被称为⾃旋锁（spin lock）**。</p>
<p>既然不想⾃旋，那当没获取到锁的时候，就把当前线程放⼊到锁的等待队列，然后执⾏调度程序，把 CPU让给其他线程执⾏。<strong>（互斥锁）</strong></p>
<p>临界区对应着一个<strong>CcriticalSection对象</strong>。当线程需要访问保护数据时，调用<strong>EnterCriticalSection</strong>函数；当对保护数据的操作完成之后，<strong>调用LeaveCriticalSection函数释放对临界区对象的拥有权</strong>，以使另一个线程可以夺取临界区对象并访问受保护的数据。</p>
<p>关键段对象会记录拥有该对象的线程句柄即其具有“线程所有权”概念，即进入代码段的线程在leave之前，可以重复进入关键代码区域。所以关键段可以用于线程间的互斥，但不可以用于同步（同步需要在一个线程进入，在另一个线程leave）</p>
<h3 id="2-互斥量">2. <strong>互斥量</strong>
</h3><p>互斥锁(又名互斥量）强调的是<strong>资源的访问互斥</strong>：互斥锁是用在多线程多任务互斥的，一个线程占用了某一个资源，那么别的线程就无法访问，<strong>直到这个线程unlock</strong>，其他的线程才开始可以利用这个资源。</p>
<p>比如<strong>对全局变量的访问，有时要加锁，操作完了，在解锁</strong>。<strong>有的时候锁和信号量会同时使用的</strong>。</p>
<p>也就是说，信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A,B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，<strong>这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类</strong>。而线程互斥量则是“锁住某一资源”的概念，在锁定期间内，其他线程无法对被保护的数据进行操作。在有些情况下两者可以互换。</p>
<p>在linux下, 线程的互斥量数据类型是pthread_mutex_t. 在使用前, 要对它进行初始化:</p>
<p>对于静态分配的互斥量, 可以把它设置为PTHREAD_MUTEX_INITIALIZER, 或者调用pthread_mutex_init.</p>
<p>对于动态分配的互斥量, <strong>在申请内存(malloc)之后, 通过</strong>pthread_mutex_init<strong>进行初始化, 并且在释放内存(free)前需要调用pthread_mutex_destroy</strong>.采用互斥对象机制</p>
<p>只有拥有了互斥对象的线程才有访问资源的权限。<strong>因为互斥对象只有一个</strong></p>
<p>所以可以保证<strong>公共资源不会被多个线程同时访问</strong>，互斥量本质上是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。</p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706203300387.png"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="哲学家进餐问题">哲学家进餐问题：
</h3><p>拿起叉⼦⽤ P 操作，代表有叉⼦就直接⽤，没有叉⼦时就等待其他哲学家放回叉⼦。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/24-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E4%B8%80%E7%A4%BA%E4%BE%8B.jpg"
	
	
	
	loading="lazy"
	
	
></p>
<p>不过，这种解法存在一个极端的问题：<strong>假设五位哲学家同时拿起左边的叉子，桌面上就没有叉子了， 这样就没有人能够拿到他们右边的叉子，也就说每一位哲学家都会在 <code>P(fork[(i + 1) % N ])</code> 这条语句阻塞了，很明显这发生了死锁的现象</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/26-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E4%BA%8C%E7%A4%BA%E4%BE%8B.jpg"
	
	
	
	loading="lazy"
	
	
></p>
<p>上⾯程序中的互斥信号量的作⽤就在于，<strong>只要有⼀个哲学家进⼊了「临界区」，也就是准备要拿叉⼦时，</strong></p>
<p><strong>其他哲学家都不能动，只有这位哲学家⽤完叉⼦了，才能轮到下⼀个哲学家进餐</strong></p>
<p>会导致只能允许⼀个哲学家就餐，那么我们就不⽤它。</p>
<p>⽅案⼀的问题在于，<strong>会出现所有哲学家同时拿左边⼑叉的可能性，那我们就避免哲学家可以同时拿</strong></p>
<p>左边的⼑叉，采⽤分⽀结构，根据哲学家的编号的不同，⽽采取不同的动作。</p>
<p><strong>即让偶数编号的哲学家「先拿左边的叉⼦后拿右边的叉⼦」，奇数编号的哲学家「先拿右边的叉⼦后拿左边的叉⼦」。</strong></p>
<p>在 P 操作时，根据哲学家的编号不同，拿起左右两边叉⼦的顺序不同。另外，V 操作是不需要分⽀的，因为 <strong>V 操作是不会阻塞的。</strong></p>
<p><strong>方案三即不会出现死锁，也可以两人同时进餐</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/28-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E4%B8%89%E7%A4%BA%E4%BE%8B.jpg"
	
	
	
	loading="lazy"
	
	
></p>
<p>方案四</p>
<p>在这里再提出另外一种可行的解决方案，我们<strong>用一个数组 state 来记录每一位哲学家的三个状态，分别是在进餐状态、思考状态、饥饿状态（正在试图拿叉子）。</strong></p>
<p>那么，<strong>一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态。</strong></p>
<p>第 <code>i</code> 个哲学家的左邻右舍，则由宏 <code>LEFT</code> 和 <code>RIGHT</code> 定义：</p>
<ul>
<li><em>LEFT</em> : ( i + 5 - 1 ) % 5</li>
<li><em>RIGHT</em> : ( i + 1 ) % 5</li>
</ul>
<p>比如 i 为 2，则 <code>LEFT</code> 为 1，<code>RIGHT</code> 为 3。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/30-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E5%9B%9B%E7%A4%BA%E4%BE%8B.jpg"
	
	
	
	loading="lazy"
	
	
></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/21-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B.jpg"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="3信号量">3.信号量
</h3><p>信号量允许同一时刻<strong>多个线程访问同一个资源，但是要控制最大线程数量</strong></p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706203212055.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li><strong>Ctrl+C 产生 <code>SIGINT</code> 信号</strong>，表示终止该进程；</li>
<li><strong>Ctrl+Z 产生 <code>SIGTSTP</code> 信号</strong>，表示停止该进程，但还未结束；</li>
</ul>
<p>对于两个并发线程，互斥信号量的值仅取 1、0 和 -1 三个值，分别表示：</p>
<ul>
<li>如果互斥信号量为 1，表示没有线程进入临界区；</li>
<li>如果互斥信号量为 0，表示有一个线程进入临界区；</li>
<li>如果互斥信号量为 -1，表示一个线程进入临界区，<strong>另一个线程等待进入。</strong></li>
</ul>
<p>通过互斥信号量的方式，就能保证临界区任何时刻只有一个线程在执行，就达到了互斥的效果。</p>
<p>如果进程在后台运行，可以通过 <code>kill</code> 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如：</p>
<ul>
<li>kill -9 1050 ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</li>
</ul>
<p>所以，信号事件的来源主要有<strong>硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）</strong>。</p>
<h3 id="4-信号">4. 信号
</h3><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p>
<p><strong>1.执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。</p>
<p><strong>2.捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</p>
<p><strong>3.忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。</p>
<p>有两个信号是应用进程无法捕捉和忽略的，<strong>即 <code>SIGKILL</code> 和 <code>SEGSTOP</code></strong>，它们用于在任何时候中断或结束某一进程</p>
<h3 id="5-读写锁">5. 读写锁
</h3><p>读写锁与互斥量类似，不过<strong>读写锁允许更高的并行性</strong>。</p>
<p>互斥量要么是锁住状态要么是不加锁状态，而且一次只有一个线程可以对其加锁。</p>
<p>读写锁可以由三种状态：<strong>读模式下加锁状态、写模式下加锁状态、不加锁状态</strong>。</p>
<p>先进先出，<strong>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。</strong></p>
<p>既然<strong>读者优先策略和写者优先策略</strong>都会造成饥饿的现象，那么我们就来实现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/34-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85-%E6%96%B9%E6%A1%88%E4%B8%89%E7%A4%BA%E4%BE%8B.jpg"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="6-条件变量condition">6. 条件变量(condition)
</h3><p><strong>条件变量是用来等待而不是用来上锁的</strong>，条件变量是利用线程间<strong>共享的全局变量</strong>进行同步的一种机制，条件变量与互斥量一起使用时，允许线程等待特定的条件发生。条件变量与互斥量一起使用时，<strong>允许线程以无竞争的方式等待特定的条件发生</strong>。</p>
<p>条件本身是由互斥量保护的。<strong>线程在改变条件状态前必须首先锁住互斥量，其它线程在获得互斥量之前不会察觉到这种改变，因此必须锁定互斥量以后才能计算条件</strong>。</p>
<p><strong>条件的检测是在互斥锁的保护下进行的</strong>。<strong>如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的互斥锁。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得互斥锁，重新评价条件</strong>。</p>
<p>如果两进程共享可读写的内存，条件变量可以被用来实现这两进程间的线程同步。</p>
<ul>
<li>
<p>如果线程正在等待共享数据内某个条件出现，那会发生什么呢？</p>
<p><strong>代码可以反复对互斥对象锁定和解锁， 以检查值的任何变化</strong>。同时，<strong>还要快速将互斥对象解锁</strong>，以便其它线程能够进行任何必需的更改。需要一种方法以唤醒因等待满足特定条件而睡眠的线程。</p>
</li>
</ul>
<h3 id="7-事件"><strong>7. 事件</strong>
</h3><p>通过<strong>通知操作的方式</strong>来保持线程的同步</p>
<p><strong>事件是内核对象</strong>，可以解决线程间同步问题，<strong>因此也能解决互斥问题</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。
</span></span><span class="line"><span class="cl">比如在某些网络应用程序中，一个线程如A负责侦听通信端口，另外一个线程B负责更新用户数据，利用事件机制，
</span></span><span class="line"><span class="cl">则线程A可以通知线程B何时更新用户数据。每个Cevent对象可以有两种状态：有信号状态和无信号状态。
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>1、使用全局变量</strong></p>
<p>主要由于多个线程可能更改全局变量，因此全局变量<strong>最好声明为volatile</strong>。</p>
<p><strong>2、使用消息实现通信</strong></p>
<p>在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage，postMessage。</p>
<h2 id="27-线程的分类">2.7 线程的分类
</h2><p><strong>内核级线程</strong>：</p>
<p>这类线程依赖于内核，又称为<strong>内核支持的线程</strong>或轻量级进程。</p>
<p>无论是在用户程序中的线程还是系统进程中的线程，<strong>它们的创建、撤销和切换都由内核实现</strong>。</p>
<p>比如英特尔i5-8250U是4核8线程，这里的线程就是内核级线程。</p>
<p><strong>内核线程是由操作系统管理的，线程对应的</strong> <strong>TCB</strong> <strong>⾃然是放在操作系统⾥的，这样线程的创建、终⽌和管理</strong>都是由操作系统负责。</p>
<p>内核线程的<strong>优点</strong>：</p>
<ul>
<li>在⼀个进程当中，如果某个内核线程发起系统调⽤⽽被阻塞，并不会影响其他内核线程的运⾏；</li>
<li>分配给线程，多线程的进程获得更多的 CPU 运⾏时间；</li>
</ul>
<p>内核线程的<strong>缺点</strong>：</p>
<ul>
<li>在⽀持内核线程的操作系统中，<strong>由内核来维护进程和线程的上下⽂信息，如 PCB 和 TCB</strong>；</li>
<li>线程的创建、终⽌和切换都是通过系统调⽤的⽅式来进⾏，因此对于系统来说，<strong>系统开销⽐较⼤</strong>；</li>
</ul>
<p><strong>用户级线程</strong>：</p>
<p>它仅存在于用户级中，这种线程是<strong>不依赖于操作系统核心</strong>的。应用进程利用<strong>线程库来完成其创建和管理</strong>，速度比较快，<strong>操作系统内核无法感知用户级线程的存在</strong>。</p>
<p>⽤户线程是基于⽤户态的线程管理库来实现的，那么<strong>线程控制块（Thread Control Block, TCB）</strong> 也是在库⾥⾯来实现的，对于操作系统⽽⾔是看不到这个 TCB 的，它只能看到整个进程的 PCB。</p>
<p>⽤户线程的<strong>优点</strong>：</p>
<ul>
<li>每个进程都需要有它私有的线程控制块（TCB）列表，⽤来跟踪记录它各个线程状态信息（<strong>PC、栈指针、寄存器</strong>），TCB 由⽤户级线程库函数来维护，<strong>可⽤于不⽀持线程技术的操作系统；</strong></li>
<li><strong>⽤户线程的切换也是由线程库函数来完成的</strong>，<strong>⽆需⽤户态与内核态的切换</strong>，所以速度特别快；</li>
</ul>
<p>⽤户线程的<strong>缺点</strong>：</p>
<ul>
<li><strong>由于操作系统不参与用户级线程的调度</strong>，<strong>如果⼀个线程发起了系统调⽤⽽阻塞</strong>，那**进程所包含的⽤户线程都不能执⾏**了。</li>
<li>当⼀个线程开始运⾏后，除⾮<strong>它主动地交出 CPU 的使⽤权</strong>，<strong>否则它所在的进程当中的其他线程⽆法运⾏，因为⽤户态的线程没法打断当前运⾏中的线程</strong>，它没有这个特权，只有操作系统才有，但是⽤户线程不是由操作系统管理的。</li>
<li>由于时间⽚分配给进程，故与其他进程⽐，<strong>在多线程执⾏时，每个线程得到的时间⽚较少</strong>，执⾏会⽐较慢；</li>
</ul>
<p><strong>轻量级进程（Light-weight process，LWP）</strong></p>
<p>是内核⽀持的⽤户线程，⼀个进程可有⼀个或多个** <strong>LWP，每个</strong> <strong>LWP</strong> <strong>是跟内核线程⼀对⼀映射的，也就是</strong> <strong>LWP</strong> <strong>都是由⼀个内核线程⽀持。</strong></p>
<p>另外，<strong>LWP 只能由内核管理并像普通进程⼀样被调度</strong>，Linux 内核是⽀持 LWP 的典型例⼦。</p>
<p>在⼤多数系统中，<strong>LWP与普通进程的区别也在于它只有⼀个最⼩的执⾏上下⽂和调度程序所需的统计信息</strong>。</p>
<p>⼀般来说，⼀个进程代表程序的⼀个实例，⽽ <strong>LWP 代表程序的执⾏线程.</strong></p>
<p><strong>因为⼀个执⾏线程不像进程那样需要那么多状态信息，所以 LWP 也不带有这样的信息</strong>。</p>
<p>在 LWP 之上也是可以使⽤⽤户线程的，那么 LWP 与⽤户线程的对应关系就有三种：</p>
<p>1 : 1 ，即⼀个 LWP 对应 ⼀个⽤户线程；</p>
<p>N : 1 ，即⼀个 LWP 对应多个⽤户线程；</p>
<p>M : N ，即多个 LMP 对应多个⽤户线程；</p>
<h2 id="28-线程池">2.8 线程池
</h2><p><strong>线程池就是提前创建若干个线程</strong>，如果有任务需要处理，<strong>线程池里的线程就会处理任务</strong>，<strong>处理完之后线程并不会被销毁，而是等待下一个任务</strong>。</p>
<p>为了减少创建和销毁线程的次数，让每个线程可以多次使用，同时可根据系统情况<strong>调整执行</strong>的线程数量，<strong>防止消耗过多<a class="link" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020"  target="_blank" rel="noopener"
    >内存</a></strong>。</p>
<p>由于<strong>创建和销毁线程都是消耗系统资源的，所以池化技术能提升性能</strong>。</p>
<p><strong>线程池的组成主要分为 3 个部分，这三部分配合工作就可以得到一个完整的线程池：</strong></p>
<ul>
<li><strong>任务<a class="link" href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&amp;spm=1001.2101.3001.7020"  target="_blank" rel="noopener"
    >队列</a></strong>，存储需要处理的任务，由工作的线程来处理这些任务
<ol>
<li><strong>通过线程池提供的 API 函数，将一个待处理的任务添加到任务队列</strong>，或者从任务队列中删除</li>
<li>已处理的任务会被从任务队列中删除</li>
<li><strong>线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程</strong></li>
</ol>
</li>
<li><strong>工作的线程</strong>（任务队列任务的消费者） ，N个
<ul>
<li>1.线程池中维护了一定数量的工作线程，他们的作用是是不停的读任务队列，从里边取出任务并处理.</li>
<li>2.<strong>工作的线程相当于是任务队列的消费者角色</strong>，</li>
<li>3.如果任务队列为空，<strong>工作的线程将会被阻塞 (使用条件变量 / 信号量阻塞)</strong></li>
<li>4.<strong>如果阻塞之后有了新的任务，由生产者将阻塞解除，工作线程开始工作</strong></li>
</ul>
</li>
<li><strong>管理者线程</strong>（不处理任务队列中的任务），1个
<ol>
<li><strong>它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测</strong></li>
<li><strong>当任务过多的时候，可以适当的创建一些新的工作线程</strong></li>
<li><strong>当任务过少的时候，可以适当的销毁一些工作的线程</strong></li>
</ol>
</li>
</ul>
<h2 id="29-进程调度">2.9 进程调度
</h2><p><strong>批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？</strong></p>
<p>批处理系统常用调度算法：</p>
<p>①、先来先服务：<a class="link" href="https://www.baidu.com/s?wd=FCFS&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao"  target="_blank" rel="noopener"
    >FCFS</a> ②、最短作业优先 ③、最短剩余时间优先 ④、响应比最高者优先</p>
<p>分时系统调度算法：</p>
<p>①、轮转调度 ②、优先级调度 ③、多级队列调度 ④、彩票调度</p>
<p>实时系统调度算法：</p>
<p>①、单比率调度 ②、限期调度 ③、最少裕度法</p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706210454043.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706210530112.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706210539267.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706210553611.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706210600929.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706210615451.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706210635305.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706210654311.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>.</p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210706210713301.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="210-多线程冲突了怎么办">2.10 多线程冲突了怎么办
</h2><p>由于多线程执行操作共享变量的这段代码可能会导致竞争状态，因此我们将此段代码称为<strong>临界区（<em>critical section</em>），它是访问共享资源的代码片段，一定不能给多线程同时执行。</strong></p>
<p>我们希望这段代码是<strong>互斥（<em>mutualexclusion</em>）的，也就说保证一个线程在临界区执行时，其他线程应该被阻止进入临界区</strong>，说白了，就是这段代码执行过程中，最多只能出现一个线程。</p>
<ul>
<li><em>锁</em>：加锁、解锁操作；</li>
<li><em>信号量</em>：P、V 操作；</li>
</ul>
<p>根据锁的实现不同，可以分为「忙等待锁」和「无忙等待锁」。</p>
<p>那什么是原子操作呢？<strong>原子操作就是要么全部执行，要么都不执行，不能出现执行到一半的中间状态</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/17-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FPV%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0.jpg"
	
	
	
	loading="lazy"
	
	
></p>
<p>PV 操作的算法描述</p>
<p><strong>多线程，为什么要用多线程</strong></p>
<ol>
<li>提高系统的并发性：多线程可以使系统同时执行多个任务，提高系统的并发性和响应能力。当一个线程被阻塞或等待某个操作完成时，其他线程可以继续执行，充分利用处理器的资源，提高系统整体的吞吐量。</li>
<li>改善用户体验：多线程可以使复杂的任务在后台运行，而不阻塞用户界面的响应。例如，在图形界面应用程序中，可以使用一个线程来处理用户界面事件和响应，另一个线程来执行耗时的计算或网络操作，这样用户可以同时进行交互而不会感到应用程序卡顿。</li>
<li>提高程序的执行效率：通过并行执行多个任务，可以充分利用多核处理器的能力，加快程序的执行速度。对于需要进行大量计算或密集的I/O操作的任务，通过多线程可以将任务分解为多个子任务并行执行，从而减少总体执行时间。</li>
<li>实现异步编程：多线程可以用于实现异步编程模型，其中一个线程可以执行长时间运行的操作，而其他线程可以继续执行其他任务。这种模型在处理网络请求、文件操作、数据库查询等需要等待外部资源响应的情况下非常有用，可以提高应用程序的性能和响应能力。</li>
<li>分解复杂任务：多线程可以将一个复杂的任务分解为多个独立的子任务，并使用不同的线程同时执行这些子任务。这样可以简化任务的管理和实现，并且可以更好地利用系统资源。</li>
</ol>
<h1 id="3-内存管理">3. 内存管理
</h1><ol>
<li>内存(memory)资源永远都是<strong>稀缺的</strong>，当越来越多的进程需要越来越来内存时，某些进程会因为得不到内存而无法运行；</li>
<li><strong>内存容易被破坏</strong>，一个进程可能误踩其他进程的内存空间；</li>
</ol>
<p>为了在<strong>多进程环境下</strong>，使得进程之间的内存地址不受影响，<strong>相互隔离，内存短缺 + 内存访问需要做保护</strong>，于是操作系统就为每个进程独立分配一套<strong>虚拟地址空间。</strong></p>
<p>操作系统引入了虚拟内存，<strong>进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系</strong>，来转换变成物理地址，然后再通过物理地址访问内存</p>
<p>每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过<strong>内存交换</strong>技术，把<strong>不常使用的内存暂时存放到硬盘（换出</strong>），在需要的时候再装载回物理内存（换入）。</p>
<ol>
<li><strong>高效使用内存</strong>：VM将主存看成是存储在磁盘上的地址空间的高速缓存，<strong>主存中保存热的数据</strong>，根据需要在磁盘和主存之间传送数据；</li>
<li><strong>简化内存管理</strong>：VM为每个进程提供了一致的地址空间，从而<strong>简化了链接、加载、内存共享</strong>等过程；</li>
<li><strong>内存保护</strong>：通过在页表条目中加入保护位，保护<strong>每个进程的地址空间不被其他进程破坏</strong>。</li>
</ol>
<h2 id="31-逻辑地址线性地址和物理地址的区别">3.1 逻辑地址、线性地址和物理地址的区别？
</h2><p><strong>逻辑地址（Logic Address）是指由程序产生的与段相关的偏移地址部分</strong>，因此一个逻辑地址<strong>由段标识符和段内偏移量</strong>组成，有时也称<strong>虚拟地址</strong>。</p>
<p>比如，在C程序中，<strong>可以使用&amp;操作读取指针变量本身的值，实际上这个值就是逻辑地址</strong>。逻辑地址和绝对的物理地址不相干。</p>
<p><strong>程序经过编译后，每个目标模块都是从0号单元开始编址</strong>，<strong>称为该目标模块的相对地址（或逻辑地址）</strong>。要通过<strong>分段地址的变化处理+分页后才会对应到相应的物理内存地址</strong>。</p>
<p><strong>线性地址（Linear Address）<strong>是逻辑地址到物理地址变换之间的</strong>中间层</strong>。</p>
<p>程序代码会产生逻辑地址，或说是<strong>段中的偏移地址</strong>，<strong>加上相应段的基地址就生成了一个线性地址。 如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。</strong></p>
<p><strong>若是没有采用分页机制，那么线性地址就是物理地址。</strong></p>
<p><strong>物理地址（Physical Address）<strong>是指内</strong>存中物理单元的集合，它是地址转换的最终地址</strong>，是CPU外部地址总线上的地址。进程在运行时执行指令和访问数据都要通过物理地址从主存中存取</p>
<p><strong>逻辑（虚拟）地址经过分段（查询段表）转化为线性地址。线性地址经过分页（查询页表）转为物理地址。</strong></p>
<p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。</p>
<p>这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。<strong>在 Linux 下，每一页的大小为 <code>4KB</code>。</strong></p>
<p>虚拟地址与物理地址之间通过<strong>页表来映射</strong>。</p>
<h2 id="32-寻址方式有哪些">3.2 寻址方式有哪些？
</h2><p><strong>寻址寻的都是物理地址</strong>。</p>
<p><strong>分三组：立即寻址+寄存器寻址；</strong></p>
<p><strong>直接间接寻址； 相对寻址+2个基变址寻址。</strong></p>
<h2 id="33-什么是虚拟内存">3.3 什么是虚拟内存？
</h2><p>虚拟内存是一种计算机系统内存管理技术。<strong>它使得应用程序认为它拥有连续可用的内存，<strong>即</strong>一个连续完整的地址空间</strong>。</p>
<p>而实际上，它通常是被分隔成<strong>多个物理内存碎片</strong>，还有部分暂时存储在外部磁盘存储器上，<strong>在需要时进行数据交换</strong>。<strong>多任务会带来进程对内存的操作冲突，需要虚拟内存来解决</strong>。</p>
<p>假设现在有一块物理内存，<strong>操作系统让两个进程共用这一块内存</strong>，彼此并不打扰。</p>
<ol>
<li>虚拟<strong>内存地址空间是连续的，没有碎片</strong></li>
<li><strong>虚拟内存的最大空间就是cpu的最大寻址空间</strong>，不受内存大小的限制，<strong>能提供比内存更大的地址空间</strong></li>
</ol>
<p>电脑中所运行的程序均需经过<a class="link" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020"  target="_blank" rel="noopener"
    >内存</a>执行，若执行的程序占用的内存很大很多，则会导致内存消耗殆尽，为解决该问题，WINDOWS运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用，这部分空间即称为虚拟内存。</p>
<ul>
<li>
<p>优点：<strong>可以弥补物理内存大小的不足</strong>；加载或交换每个用户程序到内存所需的 I/O 会更少一定程度的提高反映速度；</p>
<p>用户可以为<strong>一个巨大的虚拟地址空间编写程序</strong>，<strong>同时运行更多的程序</strong>，进而增加 CPU 利用率和吞吐量，但没有增加响应时间或周转时间**，减少对物理内存的读取从而保护内存延长内存使用寿命**；</p>
</li>
<li>
<p>缺点：<strong>占用一定的物理硬盘空间</strong>；<strong>加大了对硬盘的读写</strong>；<strong>设置不得当会影响整机稳定性与速度。</strong></p>
</li>
</ul>
<p><strong>虚拟内存技术允许执行进程不必完全处于内存</strong>。</p>
<p>这种方案的一个主要优点就是，<strong>程序可以大于物理内存</strong>。</p>
<p>此外，虚拟内存将内存抽象成一个巨大的、统一的存储数组，进而实现了用户看到的逻辑内存与物理内存的分离。这种技术使得程序员不再担忧内存容量的限制。</p>
<p>虚拟内存还<strong>允许进程轻松共享文件和实现共享内存</strong></p>
<h3 id="331-虚拟内存作用">3.3.1 虚拟内存作用
</h3><p>1、<strong>安全隔离</strong>，进程访问自身的私有内存片</p>
<p>2、<strong>共享内存</strong>，在进程之间有效共享代码库</p>
<p>3、善用碎片空间，更有效率地使用主存能够创建给主存更多的空间，<strong>每个进程都独有一个虚拟内存，并且解决主存非连续空间分配内存给某进程善用碎片空间</strong></p>
<p>4、可作为缓存用，但需要进程通过页表进行翻译，这个时候需要在<strong>通过硬件进行缓存如TLB</strong></p>
<p>Q: 假设没有虚拟内存会怎么样？</p>
<p>1、当一个进程需要的空间少于主存的时候，运行正常</p>
<p>2、当一个进程需要读取非常大的文件的时候，<strong>主存不够大，这个时候就出现缺页，切换进行效率好差</strong></p>
<p>3、当有3个进程，划分了n分空间，第四个进程没有连续空间进行划分这个时候就会出现<strong>创建不了进程</strong>，<strong>甚至出现频繁切换进程</strong></p>
<p>【总结】</p>
<p><strong>运行更安全进程独立内存地址空间，善用碎片的内存空间</strong>，从而运行更多进程提高效率</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200217135006.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="34-什么是交换空间">3.4 什么是交换空间？
</h2><p>操作系统把<strong>物理内存(physical RAM)分成一块一块的小内存</strong>，每一块内存被称为<strong>页(page)</strong>。</p>
<p>当内存资源不足时，<strong>Linux把某些页的内容转移至硬盘上的一块空间上，以释放内存空间</strong>。</p>
<p>硬盘上的那块空间叫做<strong>交换空间</strong>(swap space), 而这一过程被称为交换(swapping)。</p>
<p><strong>物理内存和交换空间的总容量就是虚拟内存的可用容量。</strong></p>
<p>用途：</p>
<ul>
<li>物理内存不足时一些不常用的页可以被交换出去，腾给系统。</li>
<li>程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。</li>
</ul>
<h2 id="35-什么是分页">3.5 什么是分页？
</h2><p>把内存空间划分为<strong>大小相等且固定的块</strong>，作为主存的基本单位。</p>
<p>因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。</strong></p>
<p><strong>访问分页系统中内存数据需要两次的内存访问.</strong></p>
<p>(第<strong>一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址</strong>；</p>
<p><strong>第二次就是根据第一次得到的物理地址访问内存取出数据</strong>。)</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218105728.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>分段的好处就是能产生连续的内存空间，但是会<strong>出现内存碎片和内存交换的空间太大</strong>的问题。</p>
<p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</p>
<p>页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作。</p>
<p>而当进程访问的虚拟地址在页表中查不到时，<strong>系统会产生一个缺页异常</strong>，<strong>进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间</strong>，恢复进程的运行。</p>
<p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。</p>
<p>而<strong>采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</strong></p>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「<strong>最近没被使用</strong>」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。</p>
<p>一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p>
<p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p>
<ul>
<li>把虚拟内存地址，切分成<strong>页号和偏移量</strong>；</li>
<li>根据页号，从<strong>页表里面，查询对应的物理页号</strong>；</li>
<li>直接拿<strong>物理页号，加上前面的偏移量</strong>，就得到了物理内存地址。</li>
</ul>
<p>因为<strong>操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。</strong></p>
<p>在 32 位的环境下，虚拟地址空间共有 4GB（2^32），假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页</p>
<p><strong>每个「页表项」需要 4 个字节大小来存储</strong>，<strong>那么整个 4GB 空间的映射就需要有 <code>4MB</code> 的内存来存储页表</strong>。</p>
<p><strong>这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。</strong></p>
<p><strong>那么，<code>100</code> 个进程的话，就需要 <code>400MB</code> 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。</strong></p>
<h2 id="36-什么是分段">3.6 什么是分段？
</h2><p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求</strong>(<strong>比如数据共享，数据保护，动态链接等)。</strong></p>
<p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。</p>
<p>由于分段管理中，<strong>每个段内部是连续内存分配</strong>，但是<strong>段和段之间是离散分配</strong>的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是<strong>段表机制</strong>。</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200218110201.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><strong>段选择⼦就保存在段寄存器</strong>⾥⾯。<strong>段选择⼦⾥⾯最重要的是段号</strong>，⽤作段表的索引。</p>
<p><strong>段表</strong>⾥⾯保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</p>
<p>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段<strong>基地址加上段内偏移量得到物理内存地址</strong></p>
<p>第⼀个就是**外部内存碎⽚**的问题。</p>
<p>第⼆个就是<strong>内存交换的效率低</strong>的问题。</p>
<p><strong>分段机制下</strong>的虚拟地址由两部分组成，<strong>段选择子</strong>和<strong>段内偏移量</strong>。</p>
<ul>
<li><strong>段选择子</strong>就保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li>
<li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li>
</ul>
<p>这里的内存碎片的问题共有两处地方：</p>
<ul>
<li>
<p><strong>外部内存碎片</strong>，也就是产生了多个不连续的小物理内存，<strong>导致新的程序无法被装载</strong>；</p>
</li>
<li>
<p><strong>内部内存碎片</strong>，<strong>程序所有的内存都被装载到了物理内存</strong>，但是这个程序有部分的内存<strong>可能并不是很常使用</strong>，这也会导致内存的浪费；</p>
</li>
<li>
<p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 <code>Swap</code> 内存区域，这个过程会产生性能瓶颈。</p>
<p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p>
<p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p>
<p>为了<strong>解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。</strong></p>
</li>
</ul>
<h2 id="37-分页分段的区别是什么">3.7 分页分段的区别是什么？
</h2><ul>
<li>属性：<strong>页是信息的物理单位</strong>，对用户不可见，<strong>段是逻辑单位</strong>，用户可见。</li>
<li>大小：<strong>分页固定，分段不固定</strong></li>
<li>决定权：<strong>分页在于系统，分段在于用户</strong></li>
<li>目的：<strong>分页有利于资源的利用，分段方便用户管理内存</strong></li>
</ul>
<ol>
<li>
<p>目的</p>
<p>页是信息的物理单位，分页是为实现离散分配方式，<strong>以消减内存的外零头，提高内存的利用率</strong>。或者说，分页是出于<strong>系统管理的需要而不是用户需要</strong>。</p>
<p>段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了<strong>更好地满足用户的需要</strong>。</p>
</li>
<li>
<p>长度</p>
<p>页的<strong>大小固定而且由系统决定</strong>，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面。</p>
<p><strong>段的长度不固定，决定于用户所编写的程序</strong>，通常由编译程序在对程序进行编译时，根据信息的性质来划分。</p>
</li>
<li>
<p>地址空间</p>
<p>页的地址空间是<strong>一维</strong>的，即单一的线形地址空间，程序员只要<strong>利用一个记忆符就可以表示一个地址</strong>。</p>
<p>作业段地址空间是<strong>二维</strong>的，程序员在标识一个地址时，<strong>既需要给出段名，又需给出段内地址</strong>。</p>
</li>
<li>
<p>碎片</p>
<p>分页有内部碎片<strong>无外部碎片</strong></p>
<p>分段有外部碎片<strong>无内部碎片</strong></p>
</li>
<li>
<p>绝对地址</p>
<p>处理器使用<strong>页号和偏移量计算绝对地址</strong></p>
<p>处理器使用<strong>段号和偏移量计算绝对地址</strong></p>
</li>
<li>
<p>管理方式</p>
<p>对于分页，操作系统必须为<strong>每个进程维护一个页表</strong>，以说明每个页对应的的页框。</p>
<p>当进程运行时，<strong>它的所有页都必须在内存中</strong>，除非<strong>使用覆盖技术或虚拟技术</strong>，另外<strong>操作系统需要维护一个空闲页框列表</strong>。</p>
<p>对于分段，操作系统必须为<strong>每个进程维护一个段表</strong>，以说明每个段的加载地址和长度。当进程运行时，它的所有短都必须在内存中，除非使用覆盖技术或虚拟技术，另外操作系统需要维护一个内存中的空闲的空洞列表。</p>
<p>特别的，当使用虚拟技术是，把一页或一段写入内存时可能需要把一页或几个段写入磁盘。</p>
</li>
<li>
<p>共享和动态链接</p>
<p><strong>分页不容易实现，分段容易实现。</strong></p>
</li>
</ol>
<h2 id="38-有哪些页面置换算法">3.8 有哪些页面置换算法？
</h2><p><strong>缺页中断</strong>：在请求分页系统中，可以通过<strong>查询页表中的状态位</strong>来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次<strong>缺页中断</strong>，此时操作系统会根据<strong>页表中的外存地址在外存中找到所缺的一页，将其调入内存</strong>。</p>
<p>有时候操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做<strong>页面置换算法。</strong></p>
<ul>
<li>
<p><strong>最佳置换算法（OPT）</strong>（理想置换算法）：从主存中<strong>移出永远不再需要的页面</strong>；如无这样的页面存在，<strong>则选择最长时间不需要访问的页面</strong>。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。</p>
</li>
<li>
<p><strong>先进先出FIFO</strong>：总是选择在<strong>主存中停留时间最长</strong>（即<strong>最老</strong>）的一页置换</p>
</li>
<li>
<p><strong>LRU</strong>：<strong>选择在最近一段时间里最久没有使用</strong>过的页面予以置换最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。</p>
</li>
<li>
<p><strong>LFU(<strong>least )：统计页的使用频率，选择在</strong>最近时期使用最少的页面作为淘汰页</strong></p>
</li>
<li>
<p><strong>NRU</strong>(Not Recently Used)：<strong>最近未用算法</strong>，通过给每一个访问的页面关联一个<strong>附加位(reference bit)</strong>，有些地方也叫做<em><strong>使用位(use bit)</strong></em>。</p>
<p>主要思想是：当某一页装入主存时，将use bit置成1；如果该页之后又被访问到，使用位也还是标记成1。对于页面置换算法，候选的帧集合可以看成是一个<strong>循环缓冲区</strong>，并且有一个指针和缓冲区相关联。遇到页面替换时，指针指向缓冲区的下一帧。<strong>如果这页进入主存后发现没有空余的帧</strong>(frame)，即所有页面的使用位均为1，那么这时候从指针开始循环一个缓冲区，<strong>将之前的使用位都清0</strong>，并且留在最初的位置上，换出该桢对应的页。</p>
</li>
<li>
<p>改进NRU：在之前的CLOCK算法上面除了<em><strong>使用位(used bit)</strong></em><em>，还增加了一个</em><strong>修改位(modified bit)</strong><em><em>，有些地方也叫做dirty bit。现在每一页有两个状态，分别**是</em>(使用位，修改位)</em>***，可分为以下四种情况考虑：</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200617192749203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0MyOTI1ODExMDgx,size_16,color_FFFFFF,t_70"
	
	
	
	loading="lazy"
	
	
></p>
<p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种<strong>频繁的页面调度行为称为抖动，或颠簸</strong>。</p>
<p>产生抖动的主要原因是<strong>进程频繁访问的页面数目高于可用的物理块数</strong>（分配给进程<strong>的物理块不够</strong>）</p>
<h2 id="39-段式内存管理">3.9 段⻚式内存管理
</h2><p>先将程序划分为多个有逻辑意义的段，也就是前⾯提到的分段机制；</p>
<p>接着再把每个段划分为多个⻚，也就是对分段划分出来的连续空间，再划分固定⼤⼩的⻚；</p>
<p><strong>第⼀次访问段表，得到⻚表起始地址；</strong></p>
<p><strong>第⼆次访问⻚表，得到物理⻚号；</strong></p>
<p><strong>第三次将物理⻚号与⻚内位移组合，得到物理地址。</strong></p>
<p>可用<strong>软、硬件相结合的方法实现段页式地址变换</strong>，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。</p>
<p><strong>Linux</strong> <strong>内存主要采⽤的是⻚式内存管理，但同时也不可避免地涉及了段机制</strong>。</p>
<p>这主要是上⾯ <strong>Intel 处理器发展历史</strong>导致的，因为 <strong>Intel X86 CPU</strong> ⼀律对程序中使⽤的<strong>地址先进⾏段式映射</strong>，然后才能进⾏<strong>⻚式映射</strong>。既然 CPU 的硬件结构是这样，Linux 内核也只好服从 Intel 的选择。</p>
<p>但是事实上，<strong>Linux 内核所采取的办法是使段式映射的过程实际上不起什么作⽤</strong>。也就是说，“上有政策，下有对策”，若惹不起就躲着⾛。</p>
<p><strong>Linux</strong> <strong>系统中的每个段都是从</strong> <strong>0</strong> <strong>地址开始的整个</strong> <strong>4GB</strong> <strong>虚拟空间（32</strong> <strong>位环境下），也就是所有的段的起始地址都是⼀样的。这意味着，Linux</strong> <strong>系统中的代码，包括操作系统本身的代码和应⽤程序代码，所⾯对的</strong></p>
<p>地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了<strong>处理器中的逻辑地址概念</strong>，段只被⽤于<strong>访问控制和内存保护。<strong>这样虽然</strong>增加了硬件成本和系统开销</strong>，<strong>但提⾼了内存的利⽤率</strong>。</p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210707231451261.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210707231435592.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="310-cache">3.10 Cache
</h2><p><strong>多级⻚表虽然解决了空间上的问题</strong>，但是虚拟地址到物理地址的转换<strong>就多了⼏道转换的⼯序</strong>，这显然就降低了这俩地址转换的速度，也就是带来了<strong>时间上的开销</strong>。</p>
<p>CPU 芯⽚中，加⼊了⼀个专⻔存放程序<strong>最常访问的⻚表项的 Cache</strong>，这个 Cache 就是 TLB</p>
<p>（<em>Translation Lookaside Buffer</em>） ，通常称为⻚表缓存、转址旁路缓存、快表等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/16-TLB.jpg"
	
	
	
	loading="lazy"
	
	
></p>
<p>在 CPU 芯片里面，封装了内存管理单元（<em>Memory Management Unit</em>）芯片，它用来完成地址转换和 TLB 的访问与交互。</p>
<p><strong>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表</strong>。</p>
<p><strong>TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。</strong></p>
<h2 id="311-linux内存分布">3.11 Linux内存分布
</h2><ul>
<li>程序文件段，包括二进制可执行代码；</li>
<li>已初始化数据段，包括<strong>静态常量</strong>；</li>
<li>未初始化数据段，包括<strong>未初始化的静态变量</strong>；</li>
<li>堆段，包括<strong>动态分配的内存</strong>，从低地址开始向上增长；</li>
<li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关 ）；</li>
<li>栈段，包括局部变量和函数调用的上下文等。<strong>栈的大小是固定的</strong>，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<p>在这 6 个内存段中，<strong>堆和文件映射段的内存是动态分配的</strong>。比如说，使用 C 标准库的 <code>malloc()</code>（br()） 或者 <code>mmap()</code> ，就可以分别在堆和文件映射段动态分配内存。</p>
<h2 id="312-malloc-是如何分配内存的">3.12 malloc 是如何分配内存的？
</h2><p>实际上，<strong>malloc() 并不是系统调用</strong>，<strong>而是 C 库里的函数</strong>，用于动态分配内存。</p>
<p>malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。</p>
<ul>
<li>方式一：<strong>通过 brk() 系统调用从堆分配内存</strong></li>
<li>方式二：<strong>通过 mmap() 系统调用在文件映射区域分配内存</strong>；</li>
</ul>
<p>方式一 实现的方式很简单，就是通过 brk() 函数将「堆顶」指针向<strong>高地址移动</strong>，获得新的内存空间。如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0dd0e2c1eb32b8b7cabfb95392a36f82.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>方式二 通过 mmap() 系统调用中「<strong>私有匿名映射</strong>」的方式，在文件映射区分配一块内存，也就是从<strong>文件映射区“偷”了一块内存</strong>。如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f8425aa73ca7e5ac8e3a46c2e3eb9188.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><strong>malloc() 源码里默认定义了一个阈值：</strong></p>
<ul>
<li><strong>如果用户分配的内存小于 128 KB</strong>，<strong>则通过 brk() 申请内存</strong>；</li>
<li>如果用户分配的内存<strong>大于 128 KB</strong>，则通过 mmap() 申请内存；</li>
</ul>
<h2 id="313-malloc-分配的是物理内存吗">3.13 malloc() 分配的是物理内存吗？
</h2><p>不是的，<strong>malloc() 分配的是虚拟内存</strong>。</p>
<p><strong>如果分配后的虚拟内存没有被访问的话，是不会将虚拟内存不会映射到物理内存</strong>，这样就不会占用物理内存了。</p>
<p>只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，<strong>发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断</strong>，然后操作系统会建立虚拟内存和物理内存之间的映射关系</p>
<p>我们在上面的进程往下执行，看看通过 free() 函数释放内存后，堆内存还在吗？</p>
<p><strong>这是因为与其把这 1 字节释放给操作系统，不如先缓存着放进 malloc 的内存池里，当进程再次申请 1 字节的内存时就可以直接复用</strong>，这样速度快了很多。</p>
<p>当然，当<strong>进程退出后，操作系统就会回收进程的所有资源</strong>。</p>
<p>上面说的 <strong>free 内存后堆内存还存在，是针对 malloc 通过 brk() 方式申请的内存的情况。</strong></p>
<p>如果 <strong>malloc 通过 mmap 方式申请的内存，free 释放内存后就会归还给操作系统</strong></p>
<p>malloc() 在分配内存的时候，并不是老老实实按用户预期申请的字节数来分配内存空间大小，而是<strong>会预分配更大的空间作为内存池</strong>。</p>
<h2 id="314-为什么不全部使用-mmap-来分配内存">3.14 为什么不全部使用 mmap 来分配内存？
</h2><p><strong>因为向操作系统申请内存，是要通过系统调用的，执行系统调用是要进入内核态的</strong>，<strong>然后在回到用户态，运行态的切换会耗费不少时间。</strong></p>
<p>所以，申请内存的操作应该避免频繁的系统调用，<strong>如果都用 mmap 来分配内存</strong>，<strong>等于每次都要执行系统调用。</strong></p>
<p>另外，<strong>因为 mmap 分配的内存每次释放的时候，都会归还给操作系统</strong>，<strong>于是每次 mmap 分配的虚拟地址都是缺页状态的</strong>，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。</p>
<p><strong>频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大</strong>。</p>
<p>为了改进这两个问题，malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以<strong>直接预分配更大的内存来作为内存池</strong>，<strong>当内存释放的时候，就缓存在内存池中</strong>。</p>
<p><strong>等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗</strong></p>
<p>但是如果下次申请的内存大于 30k，没有可用的空闲内存空间，必须向 OS 申请，实际使用内存继续增大。</p>
<p>因此，<strong>随着系统频繁地 malloc 和 free ，尤其对于小块内存，堆内将产生越来越多不可用的碎</strong>片，导致“内存泄露”。而这种“泄露”现象使用 valgrind 是无法检测出来的。</p>
<p>所以，malloc 实现中，充分考虑了 sbrk 和 mmap 行为上的差异及优缺点，<strong>默认分配大块内存 (128KB) 才使用 mmap 分配内存空间</strong></p>
<h2 id="315-free-函数只传入一个内存地址为什么能知道要释放多大的内存">3.15 free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？
</h2><p>还记得，我前面提到， <strong>malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节吗？</strong></p>
<p><strong>这个多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cb6e3ce4532ff0a6bfd60fe3e52a806e.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>这样当执行 free() 函数时，<strong>free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小</strong>，自然就知道要释放多大的内存了。</p>
<h1 id="4-系统中断">4. 系统中断
</h1><p>在CPU执行程序的过程中，<strong>出现了某种紧急情况或异常的事件时，暂停正在执行的程序，转去处理该事件，并在处理完该事件之后返回断点处（指返回主程序时执行的第一条指令的地址）继续执行刚刚被暂停的程序</strong>。</p>
<h3 id="软中断和硬中断">软中断和硬中断
</h3><p>我们通常所说的<strong>中断指的是硬中断(hardirq)</strong>。</p>
<p><strong>软中断是执行中断指令产生的，而硬中断是由外设引发的。</strong></p>
<p>硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。</p>
<p>硬中断是可屏蔽的，软中断不可屏蔽。</p>
<p>硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。</p>
<p>软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。</p>
<h2 id="41-中断的处理过程">4.1 中断的处理过程
</h2><h3 id="中断请求">中断请求
</h3><p>中断源向CPU发出中断请求，</p>
<ol>
<li>发生<strong>在CPU内部的中断（内部中断），不需要中断请求</strong>，<strong>CPU内部的中断控制逻辑直接接收处理</strong>。</li>
</ol>
<p><strong>软中断是执行中断指令产生的，</strong>  <strong>而硬中断是由外设引发的</strong>，<strong>比如当网卡收到数据包的时候，就会发出一个中断。</strong></p>
<ol start="2">
<li><strong>外部中断请求由中断源提出</strong>。<strong>外部中断源利用CPU的中断输入引脚 输入中断请求信号</strong>。</li>
</ol>
<p>一般CPU设有两个中断请求输入引脚：可屏蔽中断请求输入引脚和不可屏蔽中断请求输入引脚。</p>
<blockquote>
<p>中断请求触发器</p>
</blockquote>
<p>每个中断源发中断请求信号的时间是不确定的，而CPU在何时响应中断也是不确定的。</p>
<p>所以，<strong>每个中断源都有一个中断请求触发器</strong>，<strong>锁存自己的中断请求信号，并保持到CPU响应这个中断请求之后才将其清除。</strong></p>
<p>在CPU内部有一个<strong>中断允许触发器</strong>，当其<strong>为“1”时，允许CPU响应中断， 称为开中断</strong>。</p>
<p><strong>若其为“0”，不允许CPU响应中断，中断被屏蔽，称为关中断</strong></p>
<h3 id="中断响应">中断响应
</h3><p>① <strong>保护硬件现场（PC）和（PSW）</strong>； 把CPU的状态保存在寄存器中。</p>
<p><strong>程序计数器（Program Counter，PC）<strong>用来指出</strong>下一条指令在主存储器中的地址</strong>，</p>
<p><strong>程序状态字（Program Status Word，PSW）<strong>用来表</strong>征当前运算的状态及程序的工作方式</strong>。</p>
<p>② 关中断；</p>
<h3 id="中断服务处理阶段">中断服务处理阶段
</h3><p>1）<strong>保护现场。</strong> 在中断服务程序的起始部分安排若干条<strong>入栈指令</strong>，<strong>再将各寄存器的内容压入堆栈保存</strong>。</p>
<p>2）<strong>开中断。</strong>    <strong>在中断服务程序执行期间允许级别更高的中断请求中断现行的中断服务程序</strong>，实现<strong>中断嵌套</strong>。</p>
<p>3）<strong>中断服务。</strong> 获得<strong>中断服务程序的入口地址。<strong>完成中断源的具体要求，根据</strong>中断类型码</strong>在<strong>中断向量表</strong>中<strong>找到相应中断服务程序的入口地址</strong>。</p>
<p>4）<strong>恢复现场。</strong> 中断服务程序结束前，必须<strong>恢复主程序的中断现场</strong>。通常是将保存在堆栈中的现场信息<strong>弹出到原来的寄存器中</strong>。 <strong>返回到原程序的断点处，恢复硬件现场</strong>，继续执行原程序。</p>
<p>5）<strong>中断返回。</strong> 返回到原程序的断点处，恢复硬件现场,继续执行原程序。</p>
<h2 id="42-中断和轮询有什么区别">4.2 中断和轮询有什么区别？
</h2><p>轮询：CPU对<strong>特定设备轮流询问</strong>。                   中断：通过<strong>特定事件提醒CPU</strong>。</p>
<p>轮询：效率低等待时间长，CPU利用率不高。 中断：容易遗漏问题，<strong>CPU利用率不高</strong>。</p>
<p>CPU要和外设进行通信，可以采用轮询和中断两种方式。</p>
<p>因为轮询方式需要<strong>CPU轮询外设</strong>，<strong>查询外设是否发生中断</strong>，效率不高显而易见。于是增加了如下图的中断系统来减轻CPU负担，但是这样做效率就高了吗？</p>
<p>本质上，采用中断系统后，CPU仍然需要<strong>每隔一小段时间去查询中断控制寄存器TCON的各位状态</strong>，<strong>以判断是否有外设中断发生</strong>，否则CPU仍旧无法知道外设的当前状态。</p>
<p>如上所述，中断和轮询，好像又没啥区别，CPU仍旧<strong>摆脱不了查询的命运</strong>。</p>
<p>但是<strong>让CPU直接和各个外设逐一沟通</strong>，<strong>和让CPU只与中断控制系统机构沟通</strong>，<strong>效率是完全不一样的</strong>。</p>
<p>为了证明我的推断，我们假设, CPU外接20个不同的设备，这20个外设中在某一刻有两个外设同时中断，正好这个时候CPU来查看外设的状态，如果是轮询方式，CPU需要一一遍历20种不同的外设控制器，才能判断哪些外设刚才申请过中断，哪些外设没有申请中断。如果采用中断方式处理呢？</p>
<p><strong>CPU只需查询一下中断标志位</strong>，处<strong>理最高优先级的那个中断，其他的事情全交给中断系统去处</strong>理，效率提高了20倍！</p>
<p>从中，我们也可以发现一个现象，不论硬件设计如何巧妙，软件产品如何复杂，<strong>在设计原则上仍然是在不断的做加法。</strong></p>
<p><img src="https://images0.cnblogs.com/blog/310759/201308/04154441-5d9d1933fe544a9fbb1164acb33fcb04.jpg"
	
	
	
	loading="lazy"
	
	
></p>
<p><strong>异常与中断不同，它在产生时必须考虑与处理器时钟同步</strong>。实际上，<strong>异常也称为同步中断</strong>。</p>
<p>比如，在处理器执行到由于<strong>编程失误而导致的错误指令</strong>的时候，或者在执行期间出现特殊情况(缺页)，<strong>必须靠内核来处理的，处理器就产生一个异常。</strong></p>
<p>和中断的的工作方式类似，其差异只在于<strong>中断是由硬件而不是软件引起的</strong>。</p>
<h1 id="5-磁盘空间">5. 磁盘空间
</h1><h2 id="51-磁盘调度">5.1 磁盘调度
</h2><ul>
<li>先来先服务算法，先到来的请求，先被服务。</li>
<li>最短寻道时间优先算法，优先选择从当前磁头位置所需寻道时间最短的请求，还是以这个序列为例子：</li>
<li>扫描算法算法，最短寻道时间优先算法会产生饥饿的原因在于：磁头有可能再一个小区域内来回得移动。为了防止这个问题，可以规定：<strong>磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后的磁道，才调换方向，这就是扫描（<em>Scan</em>）算法</strong></li>
<li>循环扫描算法，只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且<strong>返回中途不处理任何请求</strong>，该算法的特点，就是<strong>磁道只响应一个方向上的请求</strong>。</li>
<li>LOOK 与 C-LOOK 算法，那这其实是可以优化的，<strong>优化的思路就是磁头在移动到「最远的请求」位置，然后立即反向移动。</strong></li>
</ul>
<h1 id="6-文件系统">6. 文件系统
</h1><h2 id="61-软硬链接">6.1 软硬链接
</h2><p>和普通文件不同的是，<strong>普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。</strong></p>
<p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过<strong>硬链接（Hard Link）</strong> 和<strong>软链接（Symbolic Link）</strong> 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p>
<p>硬链接是<strong>多个目录项中的「索引节点」指向一个文件</strong>，也就是指向同一个 inode，但是 <strong>inode 是不可能跨越文件系统</strong>的，每个文件系统都有各自的 inode 数据结构和列表，所以<strong>硬链接是不可用于跨文件系统的</strong>。</p>
<p>由于多个目录项都是指向一个 inode，那么<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</strong></p>
<p>软链接相当于重新创建一个文件，这个文件有<strong>独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可以跨文件系统的</strong>，甚至<strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</strong></p>
<h2 id="62-直接io与非直接io">6.2 直接io与非直接io
</h2><ul>
<li>
<p>直接 I/O，<strong>不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘</strong>。</p>
</li>
<li>
<p>非直接 I/O，<strong>读操作时</strong>，<strong>数据从内核缓存中拷贝给用户程序</strong>，<strong>写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘</strong>。</p>
<p>以下几种场景会触发内核缓存的数据写入磁盘：</p>
<ul>
<li>在调用 <code>write</code> 的最后，当发现<strong>内核缓存的数据太多的时候</strong>，内核会把数据写到磁盘上；</li>
<li>用户主动调用 <code>sync</code>，<strong>内核缓存会刷到磁盘上</strong>；</li>
<li>当内存十分紧张，无法再分配页面时，<strong>也会把内核缓存的数据刷到磁盘上</strong>；</li>
<li><strong>内核缓存的数据的缓存时间超过某个时间时</strong>，也会把数据刷到磁盘上；</li>
</ul>
</li>
</ul>
<h2 id="63-同步io异步io">6.3. 同步IO，异步IO
</h2><p><img src="C:%5cUsers%5cadmin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20210709181006221.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>在前⾯我们知道了，I/O 是分为两个过程的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  1. 数据准备的过程
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  2. 数据从内核空间拷⻉到⽤户进程缓冲区的过程
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>阻塞 I/O 会阻塞在「过程 1 」和「过程 2」</strong>，</p>
<p><strong>⽽⾮阻塞 I/O 和基于⾮阻塞 I/O 的多路复⽤只会阻塞在「过程2」，所以这三个都可以认为是同步 I/O。</strong></p>
<p>异步 I/O 则不同，<strong>「过程 1 」和「过程 2 」都不会阻塞。</strong></p>
<ul>
<li>
<p>食堂打饭例子</p>
<p>举个你去饭堂吃饭的例⼦，你好⽐⽤户程序，饭堂好⽐操作系统。</p>
<p>阻塞 I/O 好⽐，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就⼀直在那⾥等啊等，等了好⻓⼀段时间 <strong>终于等到饭堂阿姨把菜端了出来</strong>（数据准备的过程），但是<strong>你还得继续等阿姨把菜（内核空间）打到</strong>你的饭盒⾥（⽤户空间），经历完这两个过程，你才可以离开。</p>
<p>⾮阻塞 I/O 好⽐，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过⼏⼗分钟，你**⼜来饭堂问阿姨，阿姨说做好了**，于是阿姨帮<strong>你把菜打到你的饭盒⾥</strong>，<strong>这个过程你是得等待的</strong>。基于⾮阻塞的 I/O 多路复⽤好⽐，你去饭堂吃饭，发现有⼀排窗⼝，饭堂阿姨告诉你这些窗⼝都还没做好菜，等做好了再通知你，于是等啊等（ select 调⽤中），过了⼀会阿姨通知你菜做好了，但<strong>是不知道哪个窗⼝的菜做好了，你⾃⼰看吧</strong>。<strong>于是你只能⼀个⼀个窗⼝去确认</strong>，后⾯发现 5 号窗⼝菜做好了，于是你让 5 号窗⼝的阿姨帮你打菜到饭盒⾥，<strong>这个打菜的过程你是要等待的</strong>，虽然时间不⻓。打完菜后，你⾃然就可以离开了。</p>
<p>异步 I/O 好⽐，<strong>你让饭堂阿姨将菜做好并把菜打到饭盒⾥后</strong>，<strong>把饭盒送到你⾯前</strong>，整个过程你都不需要任何等待.</p>
</li>
</ul>
<p><strong>同步和异步IO的概念：</strong></p>
<p>同步 是<strong>用户线程发起I/O请求后</strong>需要<strong>等待</strong>或者<strong>轮询内核I/O操作</strong>完成后<strong>才能继续执行</strong></p>
<p>异步 是用户<strong>线程</strong>发起I/O请求后仍<strong>需要继续执行</strong>，<strong>当内核I/O操作完成后会通知用户线程</strong>，或者<strong>调用用户线程注册的回调函数。</strong></p>
<p><strong>阻塞和非阻塞IO的概念：</strong></p>
<p><strong>阻塞是指I/O操作需要彻底完成后才能返回用户空间。</strong></p>
<p>非阻塞是指I/O操作被调用后<strong>立即返回一个状态值</strong>，<strong>无需等I/O操作彻底完成。</strong></p>
<p><strong>IO模型</strong></p>
<p>这里统一使用Linux下的系统调用<strong>recv作为例子</strong>，它用于从套接字上接收一个消息，因为是一个系统调用，所以调用时会<strong>从用户进程空间切换到内核空间运行一段时间再切换回来</strong>。</p>
<p><strong>默认情况下recv会等到网络数据到达并且复制到用户进程空间</strong>或者<strong>发生错误时返回</strong>，而<strong>第4个参数flags可以让它马上返回。</strong></p>
<p><em>套接字</em>(Socket)，就是对网络中不同主机上的应用进程之间进行<strong>双向通信的端点的抽象</strong>。</p>
<p>一个<em>套接字</em>就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制</p>
<ul>
<li><strong>阻塞IO模型</strong></li>
</ul>
<p>使用recv的<strong>默认参数</strong>，会一直<strong>等数据直到拷贝到用户空间</strong>，这段时间内<strong>进程始终阻塞</strong>。</p>
<p>A同学用杯子装水，打开水龙头装满水然后离开。这一过程就可以看成是使用了阻塞IO模型。</p>
<p>因为如果水龙头没有水，他也要<strong>等到有水 并 装满杯子</strong>才能离开去做别的事情。很显然，这种IO模型是同步的。</p>
<p><img src="http://image.euphie.net/2017-09-24-23-18-01.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li><strong>非阻塞IO模型</strong></li>
</ul>
<p>改变flags，让recv不管有没有获取到数据都返回，如果没有数据那么一段时间后再调用recv看看，如此循环。</p>
<p>B同学也用杯子装水，打开水龙头后发现没有水，它<strong>离开</strong>了，过一会他又拿着杯子来看看……在中间离开的这些时间里，B同学离开了装水现场(<strong>回到用户进程空间</strong>)，可以做他自己的事情。这就是<strong>非阻塞IO模型。</strong></p>
<p>但是<strong>它只有是检查有无数据的时候是非阻塞的</strong>，在<strong>数据到达的时候依然要等待复制数据到用户空间(等着水将水杯装满)</strong>，因此它还是<strong>同步IO</strong>。</p>
<p><img src="http://image.euphie.net/2017-09-24-23-19-53.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li><strong>IO复用模型</strong></li>
</ul>
<p><strong>这里在调用recv前先调用select或者poll，这2个系统调用都可以在内核准备好数据(网络数据到达内核)时告知用户进程</strong>，这个时候再调用<strong>recv一定是有数据的</strong>。</p>
<p>因此这一过程中它是<strong>阻塞于select或poll</strong>，而没有阻塞于recv，有人将非阻塞IO定义成在读写操作时没有<strong>阻塞于系统调用的IO操作</strong> (不包括数据从内核复制到用户空间时的阻塞，<strong>因为这相对于网络IO来说确实很短暂</strong>)，<strong>如果按这样理解，这种IO模型也能称之为非阻塞IO模型</strong>，<strong>但是按POSIX来看，它也是同步IO</strong>，那么也和楼上一样称之为<strong>同步非阻塞IO</strong>吧。</p>
<p>这种IO模型比较特别，因为它能<strong>同时监听多个文件描述符(fd)</strong></p>
<p>一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作（这样就<strong>不需要每个用户进程不断的询问内核数据准备好了没</strong>）</p>
<p>这个时候C同学来装水，发现<strong>有一排水龙头</strong>，舍管阿姨告诉他这些水龙头都还没有水，等有水了告诉他。于是等啊等(select调用中)，<strong>过了一会阿姨告诉他有水了</strong>，<strong>但不知道是哪个水龙头有水</strong>，自己看吧。于是<strong>C同学一个个打开，往杯子里装水</strong>(recv)。</p>
<p>这里再顺便说说鼎鼎大名的epoll(高性能的代名词啊)，epoll也属于IO复用模型，</p>
<p>主要区别在于舍管阿姨会<strong>告诉C同学哪几个水龙头有水了</strong>，不需要一个个打开看(当然还有其它区别)。</p>
<p><img src="http://image.euphie.net/2017-09-24-23-21-54.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li><strong>信号驱动IO模型</strong></li>
</ul>
<p>通过调用<strong>sigaction注册信号函数</strong>，等内核数据准备好的时候系统中断当前程序，<strong>执行信号函数</strong>(在这里面调用recv)。</p>
<p>D同学让<strong>舍管阿姨等有水</strong>的时候通知他(注册信号函数)，没多久D同学得知有水了，跑去装水。是不是很像异步IO？很遗憾，它还是同步IO(<strong>省不了装水的时间啊</strong>)。</p>
<p><img src="http://image.euphie.net/2017-09-24-23-22-38.png"
	
	
	
	loading="lazy"
	
	
></p>
<ul>
<li><strong>异步IO模型</strong></li>
</ul>
<p><strong>调用aio_read</strong>，<strong>让内核等数据准备好，并且复制到用户进程空间后执行事先指定好的函数</strong>。</p>
<p>E同学让舍管阿姨将<strong>杯子装满水后通知他</strong>。整个过程E同学<strong>都可以做别的事情(没有recv)</strong>，<strong>这才是真正的异步IO。</strong></p>
<p><img src="http://image.euphie.net/2017-09-24-23-23-36.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><strong>最后，总结比较下五种IO模型：</strong></p>
<p><img src="https://images2015.cnblogs.com/blog/1066890/201611/1066890-20161129014959615-1351089676.png"
	
	
	
	loading="lazy"
	
	
></p>
<p><strong>总结</strong></p>
<p>IO分两阶段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1.数据准备阶段
</span></span><span class="line"><span class="cl">2.内核空间复制回用户进程缓冲区阶段
</span></span></code></pre></td></tr></table>
</div>
</div><p>一般来讲：阻塞IO模型、非阻塞IO模型、IO复用模型(select/poll/epoll)、信号驱动IO模型都属于同步IO，因为阶段2是阻塞的(尽管时间很短)。</p>
<p>只有异步IO模型是符合POSIX异步IO操作含义的，不管在阶段1还是阶段2都可以干别的事。</p>
<p>IO分两阶段（一旦拿到数据后就变成了数据操作，不再是IO）：</p>
<p><strong>1.数据准备阶段</strong></p>
<p><strong>2.内核空间复制数据到用户进程缓冲区（用户空间）阶段</strong></p>
<p>同步是用户<strong>线程</strong>发起I/O请求后需要<strong>等待</strong>或者<strong>轮询内核I/O操作</strong>完成后才能继续执行</p>
<p>异步是用户<strong>线程</strong>发起I/O请求后仍<strong>需要继续执行</strong>，<strong>当内核I/O操作完成后会通知用户线程</strong>，或者调用用户线程注册的回调函数</p>
<p>在操作系统中，程序运行的空间分为内核空间和用户空间。</p>
<p><strong>应用程序都是运行在用户空间的，所以它们能操作的数据也都在用户空间。</strong></p>
<p><strong>阻塞IO和非阻塞IO的区别</strong>在于<strong>第一步发起IO请求是否会被阻塞</strong>： 如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。</p>
<p><strong>同步IO和异步IO的区别</strong>就在于<strong>第二个步骤是否阻塞</strong>： 如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，否则就是异步IO</p>
<p>异步io的实现</p>
<p>来看一下基本的异步读的操作流程，我们假定发起任务的时候运行是由主线程启动的，那么：</p>
<ol>
<li>注册者申请一个异步读任务，同时将自身的<strong>一个回调</strong>注册给<strong>异步读管理器</strong>。<strong>调用者在Dispose时，必须也将自身从异步读管理器中注销</strong>。（主线程）</li>
<li>管理器在收到任务后，<strong>将相关数据封包</strong>，并<strong>启动一个新的线程（或者从线程池提取一个线程）来执行异步读任务</strong>。（主线程）</li>
<li>在子线程异步读完毕后，<strong>通知管理器提取数据</strong>。（子线程）</li>
<li>管理器处理封包，并<strong>通过调用注册者的回调来将数据重新推送下去</strong>（子线程）</li>
</ol>
<p>可以看到，在这个过程中，<strong>发起任务和处理任务分别是在主线程和子线程进行的</strong>，所以<strong>管理器自身必须有相应的同步机制来保证在不同线程上可以正确的运行。</strong></p>
<p>我们还需要考虑一个注册者同时发起多个读取任务的可能性。所以<strong>需要一定的机制来保证正确的区分这些任务</strong>。</p>
<p>在这里，我们可以选用一个较为简单的方法，即为每个注册者开辟一个单独的std::vector&lt;&gt;，<strong>并将这些任务按顺序放在vector中</strong>，同时将<strong>每个任务对应的下标返回给注册者</strong>。这样当读任务完成时，我们可以通过<strong>下标来告知注册者是哪个任务完成</strong>了。</p>
<p>读取缓冲区的<strong>分配与释放应该统一由管理器负责</strong>，而不是注册者。</p>
<p>因此<strong>注册者只能拿到一个const状态的缓冲区</strong>，如果<strong>需要使用内容则需要将其复制到自有的缓冲区。</strong></p>
<h2 id="64-如何服务更多的用户">6.4 如何服务更多的用户
</h2><p>相信你知道 TCP 连接是由四元组唯一确认的，这个四元组就是：<strong>本机IP, 本机端口, 对端IP, 对端端口</strong>。</p>
<p><strong>服务器作为服务方，通常会在本地固定监听一个端口</strong>，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以<strong>最大 TCP 连接数 = 客户端 IP 数×客户端端口数</strong>。</p>
<p>对于 IPv4，客户端的 IP 数最多为 <strong>2 的 32 次方</strong>，客户端的端口数最多为 <strong>2 的 16 次方</strong>，也就是<strong>服务端单机最大 TCP 连接数约为 2 的 48 次方</strong>。</p>
<p>这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制：</p>
<ul>
<li><strong>文件描述符</strong>，Socket 实际上是一个文件，也就会对应一个文件描述符。
<ul>
<li>在 Linux 下，单个进程打开的文件描述符数是有限制的，<strong>没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目；</strong></li>
</ul>
</li>
<li><strong>系统内存</strong>，每个 TCP 连接<strong>在内核中都有对应的数据结构</strong>，<strong>意味着每个连接都是会占用一定内存的</strong>；</li>
</ul>
<p>那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？</p>
<p><strong>并发 1 万请求，也就是经典的 C10K 问题 ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。</strong></p>
<p>从硬件资源角度看，<strong>对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。</strong></p>
<p>不过，要想真正实现 C10K 的服务器，要考虑的地方在于服务器的<strong>网络 I/O 模型</strong>，效率低的模型，会加重系统开销，从而会离 C10K 的目标越来越远。</p>
<p><strong>基于最原始的阻塞网络 I/O</strong>， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用<strong>多进程模型</strong>，也就是为每个客户端分配一个进程来处理请求。</p>
<p>服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 <code>fork()</code> 函数创建一个子进程，实际上就把父进程<strong>所有相关的东西都复制一份</strong>，包括文件描述符、内存地址空间、程序计数器、执行的代码等。</p>
<p>这两个进程刚复制完的时候，几乎一摸一样。</p>
<p>不过，会根据<strong>返回值</strong>来区分是父进程还是子进程，<strong>如果返回值是 0，则是子进程</strong>；如果返回值是其他的整数，就是父进程。</p>
<p>正因为子进程会<strong>复制父进程的文件描述符</strong>，<strong>于是就可以直接使用「已连接 Socket 」和客户端通信了</strong>，可以发现，<strong>子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」</strong>；父进程则相反，将客户服务交给子进程来处理，因此父进程<strong>不需要关心「已连接 Socket」，只需要关心「监听 Socket」</strong>。</p>
<p>下面这张图描述了从连接请求到连接建立，父进程创建生子进程为客户服务。</p>
<p>另外，当「子进程」退出时，<strong>实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作</strong>，就会变成<strong>僵尸进程</strong>，随着僵尸进程越多，会慢慢<strong>耗尽我们的系统资源</strong>。</p>
<p>因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，<strong>分别是调用 <code>wait()</code> 和 <code>waitpid()</code> 函数</strong>。</p>
<p>这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为每<strong>产生一个进程，必会占据一定的系统资源</strong>，而且进程间<strong>上下文切换的“包袱”是很重</strong>的，<strong>性能会大打折扣</strong>。</p>
<p>进程的上下文切换不仅包含了<strong>虚拟内存、栈、全局变量等用户空间的资源</strong>，<strong>还包括了内核堆栈、寄存器等内核空间的资源</strong>。</p>
<p>那么，我们可以使用<strong>线程池的方式来避免线程的频繁创建和销毁</strong>，所谓的线程池，<strong>就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出已连接 Socket 进程处理</strong>。</p>
<p>一个进程虽然任一时刻只能处理一个请求，<strong>但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求</strong>，</p>
<p>把时间拉长来看，<strong>多个请求复用了一个进程，这就是多路复用</strong>，这种思想很类似一个 <strong>CPU 并发多个进程</strong>，所以也叫做<strong>时分多路复用</strong>。</p>
<p>我们熟悉的 select/poll/epoll 内核提供给用户态的<strong>多路复用系统调用</strong>，<strong>进程可以通过一个系统调用函数从内核中获取多个事件</strong>。</p>
<p>select/poll/epoll 是如何获取网络事件的呢？</p>
<p>在获取事件时，<strong>先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。</strong></p>
<p>select/poll/epoll 这是三个多路复用接口，都能实现 C10K 吗？接下来，分别说说它们。</p>
<h2 id="65-selectpollepoll的原理区别">6.5 select，poll，epoll的原理、区别
</h2><p><strong>I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</strong>。</p>
<p><strong>select，poll，epoll都是IO多路复用的机制</strong>。但select，poll，epoll本质上都是<strong>同步I/O，<strong>因为他们</strong>都需要在读写事件就绪后自己负责进行读写</strong>，<strong>也就是说这个读写过程是阻塞的。</strong></p>
<p>而异步I/O则无需自己负责进行读写，<strong>异步I/O的实现会负责把数据从内核拷贝到用户空间</strong></p>
<p><strong>select 的核心功能是调用tcp文件系统的poll函数</strong>，<strong>不停的查询</strong>，如果没有想要的数据，<strong>主动执行一次调度（防止一直占用cpu</strong>），直到有一个连接有想要的消息为止。从这里可以看出select的执行方式基本就是不同的调用poll,直到有需要的消息为止。</p>
<h3 id="select">select:
</h3><p><strong>将已连接的 Socket 都放到一个文件描述符集合</strong>，然后<strong>调用 select 函数</strong>将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，<strong>检查的方式很粗暴</strong>，就是通过<strong>遍历文件描述符集合</strong>的方式，</p>
<p>当检查到有事件产生后，将此 Socket 标记为<strong>可读或可写</strong>， <strong>接着再把整个文件描述符集合拷贝回用户态里</strong>，<strong>然后用户态还需要再通过遍历</strong>的方法<strong>找到可读或可写的 Socket</strong>，然后再对其处理。</p>
<p>所以，对于 select 这种方式，<strong>需要进行</strong> <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，<strong>而且还会</strong>发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<p><strong>select 使用固定长度的 BitsMap</strong>，<strong>表示文件描述符集合</strong>，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 <strong>FD_SETSIZE 限制， 默认最大值为 <code>1024</code>，只能监听 0~1023 的文件描述符</strong></p>
<p><strong>缺点：</strong></p>
<p>1、<strong>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；</strong></p>
<p>2、同时每次调用select都需要在内核<strong>遍历传递进来的所有fd</strong>，这个开销在fd很多时也很大；</p>
<p>3、select支持的<strong>文件描述符数量太小了</strong>，<strong>默认是1024</strong>。</p>
<p><strong>优点：</strong></p>
<p>1、<strong>select的可移植性更好</strong>，在某些Unix系统上不支持poll()。</p>
<p>2、select对于<strong>超时值提供了更好的精度：微秒，而poll是毫秒。</strong></p>
<h3 id="poll">Poll
</h3><p><strong>poll本质上和select没有区别</strong>，<strong>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织</strong>，突破了 <strong>select 的文件描述符个数限制</strong>，当然<strong>还会受到系统文件描述符限制。</strong></p>
<p>它将用户<strong>传入的数组拷贝到内核空间</strong>，然后查询<strong>每个fd对应的设备状态</strong>，<strong>如果设备就绪则在设备等待队列中加入一项并继续遍历</strong>，<strong>如果遍历完所有fd后没有发现就绪设备</strong>，则<strong>挂起当前进程</strong>，直到<strong>设备就绪或者主动超时</strong>，<strong>被唤醒后它又要再次遍历fd</strong>。这个过程经历了多次无谓的遍历。</p>
<p><strong>poll还有一个特点是“水平触发”</strong>，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>
<p><strong>缺点：</strong></p>
<p>1、<strong>大量的fd的数组被整体复制于用户态和内核地址空间之间</strong>，而不管这样的复制是不是有意义；</p>
<p>2、与select一样，poll返回后，需要轮询<strong>pollfd来获取就绪的描述符</strong>。</p>
<p><strong>优点：</strong></p>
<p>1、poll() <strong>不要求开发者计算最大文件描述符加一的大小</strong>。</p>
<p>2、poll() 在应付<strong>大数目的文件描述符的时候速度更快</strong>，相比于select。</p>
<p>3、<strong>它没有最大连接数的限制</strong>，原因是它是基于<strong>链表来存储的。</strong></p>
<p>但是 poll 和 select <strong>并没有太大的本质区别</strong>，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p>
<h3 id="epoll"><strong>epoll</strong>
</h3><p>epoll同样<strong>只告知那些就绪的文件描述符</strong>，而且当我们调用epoll_wait()获得就绪文件描述符时， <strong>返回的不是实际的描述符</strong>，<strong>而是一个代表就绪描述符数量的值</strong>，你只需要<strong>去epoll指定的一个数组中依次取得相应数量的文件描述符即可.</strong></p>
<p>这里也使用了<strong>内存映射技术</strong>，<strong>这样便彻底省掉了这些文件描述符在系统调用时复制的开销</strong>。</p>
<ol>
<li>
<p>epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <strong><code>epoll_ctl()</code></strong> 函数加入<strong>内核中的红黑树</strong>里（<strong>红黑树是个高效的数据结构</strong>，增删查一般时间复杂度是 <code>O(logn)）</code></p>
<p>通过对<strong>这棵黑红树进行操作</strong>，这样就不需要像 <strong>select/poll 每次操作时都传入整个 socket 集合</strong>，<strong>只需要传入一个待检测的 socket</strong>，<strong>减少了内核和用户空间大量的数据拷贝和内存分配。</strong></p>
</li>
<li>
<p>epoll 使用<strong>事件驱动的机制</strong>，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，<strong>通过回调函数内核会将其加入到这个就绪事件列表中</strong>，当用户调用 <strong><code>epoll_wait()</code></strong> 函数时，<strong>只会返回有事件发生的文件描述符的个数</strong>，<strong>不需要像 select/poll 那样轮询扫描整个 socket 集合</strong>，大大提高了检测的效率。</p>
</li>
</ol>
<p><strong>epoll 被称为解决 C10K 问题的利器</strong>。</p>
<p><strong>epoll的优点就是改进了前面所说缺点：</strong></p>
<ol>
<li>
<p><strong>支持一个进程打开大数目的socket描述符</strong>：</p>
<p>相比select**，epoll则没有对FD的限制，它所支持的FD上限是最大可以打开文件的数目**，<strong>这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右</strong>，具体数目可以<strong>cat /proc/sys/fs/file-max</strong>察看,一般来说这个数目和系统内存关系很大。</p>
</li>
<li>
<p><strong>IO效率不随FD数目增加而线性下降</strong>：epoll不存在这个问题，它只会对“活跃”的socket进行操作— 这是因为在内核实现中epoll是根据<strong>每个fd上面的callback函数实现的</strong>。</p>
<p>那么，<strong>只有“活跃”的socket才会主动的去调用 callback函</strong>数，其他idle状态socket则不会，在这点上，epoll实现了一个“伪”AIO，因为这时候<strong>推动力在os内核。</strong></p>
<p>在一些 benchmark中，如果所有的socket基本上都是活跃的—比如一个高速LAN环境，epoll并不比select/poll有什么效率，相反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。</p>
</li>
<li>
<p><strong>使用mmap加速内核与用户空间的消息传递</strong>：这点实际上涉及到epoll的具体实现了。</p>
</li>
</ol>
<p>无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，<strong>如何避免不必要的内存拷贝就 很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。</strong></p>
<p><strong>执行epoll_ create时，创建了红黑树和就绪链表；</strong></p>
<p><strong>执行epoll_ ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上。</strong></p>
<p><strong>然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。</strong></p>
<p>(1) select==&gt;时间复杂度O(n)</p>
<p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时<strong>处理的流越多，无差别轮询时间就越长</strong>。</p>
<p>(2) poll==&gt;时间复杂度O(n)</p>
<p>poll本质上和select没有区别，它将用户传入的链式数组拷贝到内核空间，然后查询每个<strong>fd对应的设备状态</strong>， <strong>但是它没有最大连接数的限制</strong>，原因是它是<strong>基于链表来存储的.</strong></p>
<p>(3) epoll==<strong>&gt;时间复杂度O(1)</strong></p>
<p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的<strong>I/O事件通知我们</strong>。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）<strong>的，此时我们对这些</strong>流的操作都是有意义的</strong>。<strong>（复杂度降低到了O(1)）</strong></p>
<p><strong>水平触发</strong>(level-triggered，也被称为条件触发)LT: <strong>只要满足条件，就触发一个事件</strong> (<strong>只要有数据没有被获取，内核就不断通知你</strong>)</p>
<p><strong>边缘触发</strong>(edge-triggered)ET: <strong>每当状态变化时，触发一个事件。</strong></p>
<p>epoll 支持边缘触发和水平触发的方式，而 select/poll <strong>只支持水平触发</strong>，</p>
<p><strong>一般而言，边缘触发的方式会比水平触发的效率高。</strong></p>
<h2 id="66-dma和零拷贝">6.6 DMA和零拷贝
</h2><p>可以看到，<strong>整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程</strong>，而且这个过程，CPU 是不能做其他事情的。</p>
<p>简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。</p>
<p>计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是<strong>直接内存访问（<em>Direct Memory Access</em>）</strong> 技术。</p>
<p>什么是 DMA 技术？简单理解就是，<strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务</strong>。</p>
<ul>
<li>用户进程<strong>调用 read 方法，向操作系统发出 I/O 请求</strong>，请求读取数据到自己的内存缓冲区中，<strong>进程进入阻塞状态</strong>；</li>
<li><strong>操作系统收到请求后</strong>，<strong>进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务</strong>；</li>
<li>DMA 进一步将 <strong>I/O 请求发送给磁盘</strong>；</li>
<li><strong>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中</strong>，当磁盘控制器的<strong>缓冲区被读满后，向 DMA 发起中断信号</strong>，告知自己缓冲区已满；</li>
<li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务</strong>；</li>
<li>当 <strong>DMA 读取了足够多的数据</strong>，就会发送<strong>中断信号给 CPU</strong>；</li>
<li><strong>CPU 收到 DMA 的信号，知道数据已经准备好</strong>，于是<strong>将数据从内核拷贝到用户空间，系统调用返回；</strong></li>
</ul>
<p>可以看到， 整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，</p>
<p>但是 CPU 在这个过程中<strong>也是必不可少</strong>的，<strong>因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。</strong></p>
<p>早期 DMA 只存在在主板上，<strong>如今由于 I/O 设备越来越多</strong>，数据传输的需求也不尽相同，<strong>所以每个 I/O 设备里面都有自己的 DMA 控制器。</strong></p>
<p>传统 I/O 的工作方式是，<strong>数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</strong></p>
<ul>
<li><em>第一次拷贝</em>，把<strong>磁盘上的数据拷贝到操作系统内核的缓冲区里</strong>，这个拷贝的过程是<strong>通过 DMA 搬运的</strong>。</li>
<li><em>第二次拷贝</em>，把<strong>内核缓冲区的数据拷贝到用户的缓冲区里</strong>，于是我们<strong>应用程序就可以使用这部分数据</strong>了，<strong>这个拷贝到过程是由 CPU 完成的。</strong></li>
<li><em>第三次拷贝</em>，把<strong>刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里</strong>，<strong>这个过程依然还是由 CPU 搬运的。</strong></li>
<li><em>第四次拷贝</em>，<strong>把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png"
	
	
	
	loading="lazy"
	
	
></p>
<h3 id="如何实现零拷贝">如何实现零拷贝？
</h3><p>零拷贝技术实现的方式通常有 2 种：</p>
<ul>
<li><strong>mmap + write</strong></li>
<li>sendfile</li>
</ul>
<p>下面就谈一谈，它们是如何减少「上下文切换」和「数据拷贝」的次数。</p>
<p><strong><code>mmap()</code></strong> 系统调用函数会直接把<strong>内核缓冲区里的数据「映射」到用户空间</strong>，<strong>这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</strong></p>
<ul>
<li><strong>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里</strong>。接着，<strong>应用进程跟操作系统内核「共享」这个缓冲区；</strong></li>
<li>应用进程再调用 <strong><code>write()</code></strong>，操作系统直接将<strong>内核缓冲区的数据拷贝到 socket 缓冲区中</strong>，这一切<strong>都发生在内核态，由 CPU 来搬运数据</strong>；</li>
<li>最后，把内核的 socket 缓冲区里的数据，<strong>拷贝到网卡的缓冲区里</strong>，这个过程是由 DMA 搬运的</li>
</ul>
<p>我们可以得知，通过使用 <strong><code>mmap()</code> 来代替 <code>read()</code></strong>， 可以减少一次数据拷贝的过程。</p>
<p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍<strong>然需要 4 次上下文切换，因为系统调用还是 2 次</strong></p>
<p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 <strong>scatter-gather</strong> 特性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ ethtool -k eth0 <span class="p">|</span> grep scatter-gatherscatter-gather: on
</span></span></code></pre></td></tr></table>
</div>
</div><p>于是，从 Linux 内核 <code>2.4</code> 版本开始起，对于支持<strong>网卡支持 SG-DMA 技术</strong>的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下：</p>
<ul>
<li>第一步，通过 <strong>DMA 将磁盘上的数据拷贝到内核缓冲区里</strong>；</li>
<li>第二步，<strong>缓冲区描述符和数据长度传到 socket 缓冲区</strong>，这样<strong>网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，<strong>此过程不需要将数据</strong>从操作系统内核缓冲区拷贝到 socket 缓冲区中</strong>，这样就减少了一次数据拷贝；</li>
<li>所以，这个过程之中，只进行了 2 次数据拷贝</li>
</ul>
<p>这就是所谓的<strong>零拷贝（<em>Zero-copy</em>）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的</strong>。</p>
<p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p>
<p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p>
<p><strong>零拷贝技术</strong>是基于 <strong>PageCache 的</strong>，<strong>PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能。</strong></p>
<p>同时，为了解决机械硬盘寻址慢的问题，<strong>它还协助 I/O 调度算法实现了 IO 合并与预读</strong>，这也是<strong>顺序读比随机读性能好</strong>的原因。这些优势，进一步提升了零拷贝的性能。<strong>PageCache 使用了「预读功能」</strong>。</p>
<p>比如，假设 read 方法每次只会读 <code>32 KB</code> 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但<strong>内核会把其后面的 32～64 KB 也读取到 PageCache</strong>，这样后面读取 32～64 KB 的成本就很低，<strong>如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常高。</strong></p>
<p><strong>事实上，Kafka 这个开源项目，就利用了「零拷贝」技术</strong>，<strong>从而大幅提升了 I/O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。</strong></p>
<p>另外，<strong>Nginx 也支持零拷贝技术</strong>，<strong>一般默认是开启零拷贝技术</strong>，<strong>这样有利于提高文件传输的效率</strong>，是否开启零拷贝技术的配置如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="67-大文件传输">6.7 大文件传输
</h2><ul>
<li><strong>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗</strong>。在 MySQL 数据库中，可以<strong>通过参数设置开启直接 I/O，默认是不开启；</strong></li>
<li>传输大文件的时候，<strong>由于大文件难以命中 PageCache 缓存</strong>，<strong>而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销</strong>，因此，<strong>这时应该使用直接 I/O</strong>。</li>
</ul>
<p>另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：</p>
<ul>
<li><strong>内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中</strong>，最后「<strong>合并」成一个更大的 I/O 请求再发给磁盘</strong>，这样做是为了<strong>减少磁盘的寻址操</strong>作；</li>
<li>内核也会「<strong>预读</strong>」<strong>后续的 I/O 请求</strong>放在 PageCache 中，一样是为了减少对磁盘的操作；</li>
</ul>
<p>于是，**传输大文件的时候，使用「异步 I/O + 直接 I/O」**了，<strong>就可以无阻塞地读取文件了。</strong></p>
<p>所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：</p>
<ul>
<li><strong>传输大文件的时候，使用「异步 I/O + 直接 I/O」；</strong></li>
<li><strong>传输小文件的时候，则使用「零拷贝技术」；</strong></li>
</ul>
<p>另外，当传输大文件时，不能使用零拷贝，因为可能由于 PageCache 被大文件占据，<strong>而导致「热点」小文件无法利用到 PageCache</strong>，并且大文件的缓存命中率不高，这时就需要使用「异步 IO + 直接 IO 」的方式。</p>
<p><strong>在 Nginx 里，可以通过配置，设定一个文件大小阈值</strong>，<strong>针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。</strong></p>
<h2 id="68-socket模型">6.8 Socket模型
</h2><p>要想客户端和服务器能在网络中通信，那必须得使用 Socket 编程，它是进程间通信里比较特别的方式，特别之处在于它是可以跨主机间通信。</p>
<ul>
<li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li>
<li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li>
<li>服务端调用 <code>listen</code>，进行监听；</li>
<li>服务端调用 <code>accept</code>，等待客户端连接；</li>
<li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li>
<li>服务端 <code>accept</code> 返回用于<strong>传输的 <code>socket</code> 的文件描述符；</strong></li>
<li>客户端调用 <code>write</code> 写入数据；<strong>服务端调用 <code>read</code> 读取数据；</strong></li>
<li>客户端断开连接时，会调用 <code>close</code>，<strong>那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code></strong>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li>
</ul>
<p>创建 Socket 的时候，可以指定<strong>网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP。</strong></p>
<p>主线程：</p>
<ol>
<li>
<p><strong>创建完成端口对象</strong></p>
</li>
<li>
<p><strong>创建工作者线程</strong>（这里工作者线程的数量是按照CPU核的个数来决定，这样可以达到最佳性能）</p>
</li>
<li>
<p><strong>创建监听套接字，绑定，监听，然后程序进入循环</strong></p>
</li>
<li>
<p>在循环中，做了以下几件事情：</p>
<p>(1) <strong>接受一个客户端连接</strong></p>
<p>(2) 将<strong>该客户端套接字与完成端口绑定到一起</strong>(还是调用CreateIoCompletionPort，但这次的作用不同)。</p>
<p>注意，按道理来讲，此时传递给CreateIoCompletionPort的第三个参数应该是一个完成键，一般来讲，**程序都是传递一个单句柄数据结构的地址，**该单句柄数据包含了和该客户端连接有关的信息，由于我们只关心套接字句柄，<strong>所以直接将套接字句柄作为完成键传递；</strong></p>
<p>(3) 触发一个WSARecv异步调用，这次又用到了“<strong>尾随数据”，使接收数据所用的缓冲区紧跟在WSAOVERLAPPED对象之后</strong>，此外，还有操作 类型等重要信息。</p>
</li>
</ol>
<h1 id="7-设备管理">7. 设备管理
</h1><p>我们的电脑设备可以接非常多的输入输出设备，比如键盘、鼠标、显示器、网卡、硬盘、打印机、音响等等，每个设备的用法和功能都不同，那操作系统是如何把这些输入输出设备统一管理的呢?</p>
<p>为了屏蔽设备之间的差异，<strong>每个设备都有一个叫设备控制器（<em>Device Control</em>）</strong> 的组件，比如硬盘有硬盘控制器、显示器有视频控制器等。</p>
<ul>
<li><em><strong>数据寄存器</strong></em>，<strong>CPU 向 I/O 设备写入需要传输的数据</strong>，比如要打印的内容是「Hello」，CPU 就要先发送一个 H 字符给到对应的 I/O 设备。</li>
<li><em><strong>命令寄存器</strong></em>，<strong>CPU 发送一个命令，告诉 I/O 设备，要进行输入/输出操作，于是就会交给 I/O 设备去工作</strong>，任务完成后，会把状态寄存器里面的状态标记为完成。</li>
<li><em><strong>状态寄存器</strong></em>，目的是告诉 CPU ，<strong>现在已经在工作或工作已经完成，如果已经在工作状态，CPU 再发送数据或者命令过来，都是没有用的，直到前面的工作已经完成</strong>，状态寄存标记成已完成，CPU 才能发送下一个字符和命令。</li>
</ul>
<h2 id="71-键盘敲入字母时期间发生了什么">7.1 键盘敲入字母时，期间发生了什么？
</h2><p>那当用户输入了键盘字符，<strong>键盘控制器</strong>就会产生<strong>扫描码数据</strong>，并将其缓冲在<strong>键盘控制器的寄存器</strong>中，紧接着键盘控制器通过<strong>总线给 CPU</strong> 发送<strong>中断请求</strong>。</p>
<p>CPU 收到中断请求后，操作系统会<strong>保存被中断进程的 CPU 上下文</strong>，然后调用键盘的<strong>中断处理程序</strong>。</p>
<p><strong>键盘的中断处理程序是在键盘驱动程序初始化时注册的</strong>，那键盘<strong>中断处理函数的功能就是从键盘控制器的寄存器的缓冲区读取扫描码，再根据扫描码找到用户在键盘输入的字符</strong>，**如果输入的字符是显示字符，那就会把扫描码翻译成对应显示字符的 ASCII 码（**比如用户在键盘输入的是字母 A，是显示字符，于是就会把扫描码翻译成 A 字符的 ASCII 码）</p>
<p><strong>得到了显示字符的 ASCII 码后，就会把 ASCII 码放到「读缓冲区队列」，接下来就是要把显示字符在屏幕上了，显示设备的驱动程序会定时从「读缓冲区队列」读取数据放到「写缓冲区队列」</strong>，<strong>最后把「写缓冲区队列」的数据一个一个写入到显示设备的控制器的寄存器中的数据缓冲区，最后将这些数据显示在屏幕里。</strong></p>
<p><strong>显示出结果后，恢复被中断进程的上下文</strong>。</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/computer-system/">Computer System</a>
        
            <a href="/tags/408/">408</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2018 - 
        
        2025 salmone
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
