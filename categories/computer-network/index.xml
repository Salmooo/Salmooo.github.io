<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Computer Network on SalmoneX Blog</title>
        <link>https://Salmooo.github.io/categories/computer-network/</link>
        <description>Recent content in Computer Network on SalmoneX Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>salmone</copyright>
        <lastBuildDate>Mon, 18 Nov 2019 21:45:27 +0800</lastBuildDate><atom:link href="https://Salmooo.github.io/categories/computer-network/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>计算机网络常见问题1</title>
        <link>https://Salmooo.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%981/</link>
        <pubDate>Mon, 18 Nov 2019 21:45:27 +0800</pubDate>
        
        <guid>https://Salmooo.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%981/</guid>
        <description>&lt;h1 id=&#34;问题&#34;&gt;问题
&lt;/h1&gt;&lt;h2 id=&#34;71-浏览器中输入url地址到显示主页的过程是什么&#34;&gt;7.1 浏览器中输入URL地址到显示主页的过程是什么？
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214133606.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;URL解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址解析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先判断你输入的是一个&lt;strong&gt;合法的 URL 还是一个待搜索的关键词&lt;/strong&gt;，并且根据你输入的内容进行&lt;strong&gt;自动完成、字符编码&lt;/strong&gt;等操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HSTS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：&lt;a class=&#34;link&#34; href=&#34;https://www.barretlee.com/blog/2015/10/22/hsts-intro/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;你所不知道的 HSTS&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器还会进行一些额外的操作，比如安全检查、访问限制（&lt;strong&gt;之前国产浏览器限制 996.icu）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检查缓存304&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic1.zhimg.com/v2-0489444034d569b37867e2e527a7d5d4_r.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DNS解析&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 浏览器缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器会先检查是否在浏览器缓存中&lt;/strong&gt;，没有则调用系统库函数进行查询。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 操作系统缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;操作系统也有自己的 DNS缓存，但在这之前，&lt;strong&gt;会向检查域名是否存在本地的 Hosts 文件里&lt;/strong&gt;，没有则向 DNS 服务器发送查询请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 路由器缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路由器也有自己的缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. ISP DNS 缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根域名服务器查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic2.zhimg.com/v2-57eb007db72ad239123d56448a2a1d01_r.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根域名服务器：维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;需要注意的点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;递归方式：&lt;strong&gt;一路查下去中间不返回，得到最终结果才返回信息&lt;/strong&gt;（&lt;strong&gt;浏览器到本地DNS服务器的过程&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;迭代方式，就是&lt;strong&gt;本地DNS服务器到根域名服务器查询的方式。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么是 DNS 劫持&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DNS劫持又叫域名劫持&lt;/strong&gt;,指攻击者利用其他攻击手段,&lt;strong&gt;篡改了某个域名的解析结果&lt;/strong&gt;,使得指向该域名的IP变成了另一个IP,导致对相应网址的访问被劫持到&lt;strong&gt;另一个不可达的或者假冒的网址&lt;/strong&gt;,从&lt;strong&gt;而实现非法窃取用户信息或者破坏正常网络服务的目的&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前端 dns-prefetch 优化&lt;/p&gt;
&lt;p&gt;DNS预获取，是前端优化的一部分。 一个&lt;strong&gt;是减少DNS的请求次数&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP连接&lt;/p&gt;
&lt;p&gt;根据IP建立TCP连接（三次握手）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发送HTTP请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器处理请求并&lt;strong&gt;返回HTTP报文&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器解析渲染页面&lt;/p&gt;
&lt;p&gt;渲染页面，构建DOM树&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接结束&lt;/p&gt;
&lt;p&gt;关闭TCP连接（四次挥手）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;72-ping命令的具体过程是什么&#34;&gt;7.2 ping命令的具体过程是什么？
&lt;/h2&gt;&lt;p&gt;简单来说，「ping」是用来探测&lt;strong&gt;本机与网络中另一主机之间是否可达的命令&lt;/strong&gt;，如果两台主机之间ping不通，则表明这两台主机不能建立起连接。ping是定位网络通不通的一个重要手段。&lt;/p&gt;
&lt;p&gt;ping 命令是基于 &lt;strong&gt;ICMP 协议&lt;/strong&gt;来工作的，「 ICMP 」全称为 &lt;strong&gt;Internet 控制报文协议&lt;/strong&gt;（ Internet Control Message Protocol）。&lt;/p&gt;
&lt;p&gt;ping 命令会发送一份ICMP回显请求报文给目标主机，并等待目标主机返回ICMP回显应答。因为&lt;strong&gt;ICMP协议会要求目标主机在收到消息之后&lt;/strong&gt;，必须&lt;strong&gt;返回ICMP应答消息&lt;/strong&gt;给源主机，如果源主机&lt;strong&gt;在一定时间内收到了目标主机的应答，则表明两台主机之间网络是可达的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设现在有ABCD四台主机，一台路由，子网掩码为255.255.255.0，默认路由为192.168.0.1&lt;/p&gt;
&lt;p&gt;在主机 A 上运行&lt;code&gt;Ping 192.168.0.5&lt;/code&gt;后,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ping命令&lt;strong&gt;会构建一个ICMP协议的数据包，交到网络层的IP协议中&lt;/strong&gt;。IP层协议将目的地址和源地址和一些其它的控制信息打包后，形成IP数据包&lt;/li&gt;
&lt;li&gt;通过&lt;strong&gt;ARP映射表获取192.168.0.5的MAC地址&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交到数据链路层，添加一些控制信息，构建数据帧&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交到物理层，通过以太网访问&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主机B收到后，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查目的地址，不相符就丢弃&lt;/li&gt;
&lt;li&gt;将IP数据包提取后送入网络层的IP层协议，&lt;strong&gt;IP层检查后将有用的信息提取后送入ICMP协议&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ICMP协议马上构建一个&lt;strong&gt;ICMP应答包以之前的相同方式发送给主机&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据条件：&lt;strong&gt;是否在同一网段内&lt;/strong&gt;，流程可能有所不同，区别在于MAC的获取方式，具体参见ARP协议。&lt;/p&gt;
&lt;h2 id=&#34;73-什么是负载均衡负载均衡算法有哪些&#34;&gt;7.3 什么是负载均衡，负载均衡算法有哪些？
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;负载均衡是&lt;/strong&gt;高可用网络基础架构的关键组件，通常用于将&lt;strong&gt;工作负载分布到多个服务器&lt;/strong&gt;来提高网站、应用、数据库或其他服务的&lt;strong&gt;性能和可靠性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多台服务器以对称的方式组成一个服务器集合&lt;/strong&gt;，每台服务器都具有&lt;strong&gt;等价的地位&lt;/strong&gt;，&lt;strong&gt;能互相分担负载&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;轮询法&lt;/strong&gt;：&lt;strong&gt;将请求按照顺序轮流的分配到服务器上&lt;/strong&gt;。大锅饭，不能发挥某些高性能服务器的优势&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;随机法&lt;/strong&gt;：&lt;strong&gt;随机获取一台&lt;/strong&gt;，和轮询类似&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希法&lt;/strong&gt;：&lt;strong&gt;通过ip地址哈希化来确定要选择的服务器编号&lt;/strong&gt;。好处是，&lt;strong&gt;每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加权轮询&lt;/strong&gt;：根据服务器&lt;strong&gt;性能不同加权&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一致性哈希&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同的负载均衡算法适用的业务场景也不同的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;轮询这类的策略只能适用与每个节点的数据都是相同的场景，访问任意节点都能请求到数据。但是不适用分布式系统&lt;/strong&gt;，因为分布式系统意味着&lt;strong&gt;数据水平切分到了不同的节点上&lt;/strong&gt;，访问数据的时候，一定要寻址存储该数据的节点。&lt;/p&gt;
&lt;p&gt;哈希算法虽然能建立数据和节点的映射关系，&lt;strong&gt;但是每次在节点数量发生变化的时候，最坏情况下所有数据都需要迁移&lt;/strong&gt;，这样太麻烦了，所以不适用节点数量变化的场景。&lt;/p&gt;
&lt;p&gt;为了减少迁移的数据量，就出现了一致性哈希算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是一致性哈希算法不能够均匀的分布节点，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时&lt;/strong&gt;，容易出现雪崩的连锁反应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了解决一致性哈希算法不能够均匀的分布节点的问题，就需要引入虚拟节点&lt;/strong&gt;，对一个真实节点做多个副本。不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，&lt;strong&gt;所以这里有「两层」映射关系。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。&lt;/p&gt;
&lt;h2 id=&#34;74-ssl的工作原理&#34;&gt;7.4 SSL的工作原理
&lt;/h2&gt;&lt;p&gt;SSL与TLS SSL：（&lt;strong&gt;Secure Socket Layer&lt;/strong&gt;，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。&lt;/p&gt;
&lt;p&gt;SSL通过&lt;strong&gt;互相认证、使用数字签名&lt;/strong&gt;确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。&lt;/p&gt;
&lt;p&gt;TLS：(Transport Layer Security，传输层安全协议)，TLS（传输层安全）是更&lt;strong&gt;为安全的升级版 SSL&lt;/strong&gt;，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：&lt;strong&gt;TLS记录协议和TLS握手协议。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的&lt;/strong&gt;，在将 TLS 证书部署服务端时，证书文件中包含一对公私钥，&lt;strong&gt;其中公钥会在 TLS 握手阶段传递给客户端&lt;/strong&gt;，私钥则一直留在服务端，一定要确保私钥不能被窃取。在 RSA 密钥协商算法中，&lt;strong&gt;客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SSL/TLS历史 1994年，&lt;strong&gt;NetScape公司设计了SSL协议&lt;/strong&gt;（Secure Sockets Layer）的1.0版，但是未发布。&lt;/p&gt;
&lt;p&gt;1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。&lt;/p&gt;
&lt;p&gt;1996年，SSL 3.0版问世，得到大规模应用。 1999年，**互联网标准化组织ISOC接替NetScape公司，**发布了SSL的升级版TLS 1.0版。&lt;/p&gt;
&lt;p&gt;2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版，在2018年也发布了TLS1.3版本。 TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。&lt;/p&gt;
&lt;p&gt;目前&lt;strong&gt;应用的最广泛的 TLS 是 1.2&lt;/strong&gt;，而之前的协议（TLS1.1/1.0、SSLv3/v2）都&lt;strong&gt;已经被认为是不安&lt;/strong&gt;全的了。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://img-blog.csdn.net/20180920154005922?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SSL/TLS协议的基本过程&lt;/p&gt;
&lt;p&gt;（1） &lt;strong&gt;客户端向服务器端索要并验证公钥&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（2） &lt;strong&gt;双方协商生成“对话密钥”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（3） &lt;strong&gt;双方采用“对话密钥”进行加密通信&lt;/strong&gt;。 上面过程的前两步，又称为**“握手阶段”（handshake）**&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TLS/SSL的功能实现主要依赖于三类基本算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;散列函数 Hash、对称加密DES、3DES、IDEA、AES和非对称加密RSA、DSA、ECC、Diffie-Hellman，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CA证书&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现实中，通过CA（Certificate Authority）来保证public key的真实性。&lt;strong&gt;CA也是基于非对称加密算法&lt;/strong&gt;来工作。&lt;/p&gt;
&lt;p&gt;有了CA，&lt;strong&gt;B会先把自己的public key（和一些其他信息）交给CA。CA用自己的private key加密这些数&lt;/strong&gt;据，&lt;strong&gt;加密完的数据称为B的数字证书&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在B要向A传递public key，B传递的是CA加密之后的数字证书。&lt;strong&gt;A收到以后，会通过CA发布的CA证书（包含了CA的public key），来解密B的数字证书，从而获得B的public key。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是等等，A怎么确保CA证书不被劫持。C完全可以把一个假的CA证书发给A，进而欺骗A。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CA的大杀器就是，CA把自己的CA证书集成在了浏览器和操作系统里面&lt;/strong&gt;。A拿到浏览器或者操作系统的时候，&lt;strong&gt;已经有了CA证书，没有必要通过网络获取&lt;/strong&gt;，那自然也不存在劫持的问题。&lt;/p&gt;
&lt;h3 id=&#34;tls-握手&#34;&gt;&lt;strong&gt;TLS 握手&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;TLS第一次握手&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端首先会发一个「&lt;strong&gt;Client Hello&lt;/strong&gt;」消息&lt;/p&gt;
&lt;p&gt;消息里面有客户端使用的 &lt;strong&gt;TLS 版本号&lt;/strong&gt;、&lt;strong&gt;支持的密码套件列表&lt;/strong&gt;，以及生成的&lt;strong&gt;随机数（&lt;em&gt;Client Random&lt;/em&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个随机数会被服务端保留，它是生成对称加密密钥的材料之一&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TLS 第二次握手&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当服务端收到客户端的「Client Hello」消息后，&lt;strong&gt;会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件&lt;/strong&gt;，以及生成&lt;strong&gt;随机数（&lt;em&gt;Server Random&lt;/em&gt;）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;接着，返回「&lt;strong&gt;Server Hello&lt;/strong&gt;」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。&lt;/p&gt;
&lt;p&gt;这个密码套件看起来真让人头晕，好一大串，但是其实它是有固定格式和规范的。基本的形式是「&lt;strong&gt;密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法&lt;/strong&gt;」&lt;/p&gt;
&lt;p&gt;Diffie-Hellman密钥交换算法:&lt;/p&gt;
&lt;p&gt;-&lt;/p&gt;
&lt;p&gt;Diffie-Hellman密钥交换算法是一种用于在不安全的通信信道上安全地交换密钥的算法。它允许两个通信方在没有事先共享密钥的情况下协商出一个共享的对称密钥，该密钥可以用于后续的加密通信。&lt;/p&gt;
&lt;p&gt;Diffie-Hellman算法的基本思想是利用数论中的离散对数问题。具体步骤如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. **参数选择**：选择两个大素数p和g，其中p是一个素数，g是一个原根（即对于任意小于p的正整数a，都存在一个整数k使得$g^k ≡ a \mod p$）。
2. **密钥生成**：
    - 选择私密参数：每个通信方选择一个私密参数（私钥）。假设Alice选择私钥a，Bob选择私钥b。
    - 计算公开参数：计算公开参数（公钥）。Alice计算$A = g^a \mod p$，Bob计算$B = g^b \mod p$。
    - 交换公开参数：Alice将A发送给Bob，Bob将B发送给Alice。
3. **密钥协商**：
    - 计算共享密钥：Alice使用Bob发送的B和自己的私钥a计算共享密钥$K = B^a \mod p$，Bob使用Alice发送的A和自己的私钥b计算共享密钥$K = A^b \mod p$。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于离散对数问题的困难性，即使攻击者能够截获Alice和Bob之间的通信，也很难从A、B和p中推导出共享密钥K，因此Diffie-Hellman算法能够安全地协商出一个共享密钥，用于后续的加密通信。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TLS 第三次握手&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公钥；&lt;/li&gt;
&lt;li&gt;持有者信息；&lt;/li&gt;
&lt;li&gt;证书认证机构（CA）的信息；&lt;/li&gt;
&lt;li&gt;CA 对这份文件的数字签名及使用的算法；&lt;/li&gt;
&lt;li&gt;证书有效期；&lt;/li&gt;
&lt;li&gt;还有一些其他额外信息；&lt;/li&gt;
&lt;li&gt;数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端验证完证书后，认为可信则继续往下走。接着，客户端就会生成一个新的&lt;strong&gt;随机数 (&lt;em&gt;pre-master&lt;/em&gt;)&lt;/strong&gt;，用服务器的 RSA 公钥加密该随机数，通过**「Change Cipher Key Exchange」消息传给服务端。**&lt;/p&gt;
&lt;p&gt;那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件&lt;/p&gt;
&lt;p&gt;所谓的会话密钥就是数据传输时，所使用的对称加密密钥。&lt;/p&gt;
&lt;p&gt;于是，&lt;strong&gt;双方根据已经得到的三个随机数&lt;/strong&gt;，生成&lt;strong&gt;会话密钥（Master Secret），它是对称密钥&lt;/strong&gt;，用于对后续的 HTTP 请求/响应的数据加解密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TLS 第四次握手&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务器也是同样的操作，发「&lt;strong&gt;Change Cipher Spec&lt;/strong&gt;」和「&lt;strong&gt;Encrypted Handshake Message&lt;/strong&gt;」消息，&lt;strong&gt;如果双方都验证加密和解密没问题，那么握手正式完成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTPS ECDHE 握手解析&lt;/p&gt;
&lt;p&gt;分别是 RSA 和 ECDHE 算法。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;rsa-和-ecdhe-握手过程的区别&#34;&gt;RSA 和 ECDHE 握手过程的区别：
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;RSA 密钥协商算法「不支持」前向保密，&lt;strong&gt;ECDHE 密钥协商算法「支持」前向保密，非对称密钥&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;使用了 RSA 密钥协商算法，T&lt;strong&gt;LS 完成四次握手后，才能进行应用数据传输&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;而对于 ECDHE 算法，**客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，**节省了一个消息的往返时间；&lt;/li&gt;
&lt;li&gt;使用 ECDHE， 在 &lt;strong&gt;TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息&lt;/strong&gt;，而 RSA 握手过程没有该消息；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;75-路由器是如何选择最佳路径的&#34;&gt;7.5 路由器是如何选择最佳路径的
&lt;/h2&gt;&lt;p&gt;路由器是一种用于网络互连的专用计算机设备,在网路建设中有着重要的地位.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路由器工作在OSI参考模型的第三层(网络层),&lt;strong&gt;主要的作用是为&lt;/strong&gt;收到的报文寻找正确的路径,并把他们转发出去&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;在这个过程中,路由器被认为执行了两个最重要的基本功能:&lt;strong&gt;路由功能和交换功能.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一个特定的路由协议,可以发现到达目的网络的所有路径, &lt;strong&gt;根据选路算法赋予每一条路径metric值,比较metric值,选择metric值最小的路径为最佳路径&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;在路由器的交换过程中查找路由时可能会发现能匹配上多条路由条目.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此时路由器将根据掩码长度最长匹配原则进行数据的转发&lt;/strong&gt;.路由器会进行匹配最深的,&lt;strong&gt;也就是说可以匹配的掩码长度最长的一条路由进行转发&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第一，&lt;strong&gt;最长掩码匹配原则&lt;/strong&gt;；例如，查找去往192.168.1.1的路径时，发现路由表有如下两个表项 192.168.1.0 mask 255.255.255.0 next hop 10.1.1.1&lt;/p&gt;
&lt;p&gt;192.168.1.0 mask 255.255.0.0 next hop 172.16.1.1&lt;/p&gt;
&lt;p&gt;路由器会选择第一条路由转发，因为&lt;strong&gt;第一条的IP地址范围更小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二，如果路由表中目的&lt;strong&gt;网段的范围相同&lt;/strong&gt;，&lt;strong&gt;路由优先级高者优先&lt;/strong&gt;（&lt;strong&gt;优先级数值越小，优先级越高&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;第三，如果路由表中目的网段的范围相同，并且路由优先级也相同，&lt;strong&gt;开销（metric）小的优先（metric值越小，开销越小）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路由选择算法可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局式&lt;/strong&gt;路由选择算法：所有路由器&lt;strong&gt;掌握完整的网络拓扑和链路费用信息&lt;/strong&gt;，例如&lt;strong&gt;链路状态(LS)路由算法&lt;/strong&gt;，链路状态路由选择算法可以用Dijksua算法实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分散式&lt;/strong&gt;路由选择算法；路由器只掌握&lt;strong&gt;物理相连的邻居以及链路费用&lt;/strong&gt;，例如距离向量(DV)路由算法，距离向量路由选择算法可以用&lt;strong&gt;Bellman-Ford方程dx(y) = min {c(x,v) + dv(y)}实现。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;76-子网掩码的作用&#34;&gt;7.6 子网掩码的作用
&lt;/h2&gt;&lt;p&gt;1、一是用于&lt;strong&gt;屏蔽IP地址的一部分&lt;/strong&gt;以&lt;strong&gt;区别网络标识和主机标识&lt;/strong&gt;，&lt;strong&gt;并说明该IP地址是在局域网上，还是在远程网上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、二是用于将一个&lt;strong&gt;大的IP网络划分为若干小的子网络。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用子网是&lt;strong&gt;为了减少IP的浪费&lt;/strong&gt;。因为随着互联网的发展，越来越多的网络产生，有的网络多则几百台，有的只有区区几台，这样就浪费了很多IP地址，所以要划分子网。&lt;strong&gt;使用子网可以提高网络应用的效率。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;77-http请求报文和响应报文分别由哪些部分组成&#34;&gt;7.7 HTTP请求报文和响应报文分别由哪些部分组成？
&lt;/h2&gt;&lt;h3 id=&#34;http请求报文&#34;&gt;HTTP请求报文
&lt;/h3&gt;&lt;p&gt;由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic002.cnblogs.com/images/2012/426620/2012072810301161.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;img&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.请求头&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请求行由请&lt;strong&gt;求方法字段、URL字段和HTTP协议版本&lt;/strong&gt;字段3个字段组成，它们用空格分隔。例如，&lt;strong&gt;GET /index.html HTTP/1.1。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.请求头部&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有：&lt;/p&gt;
&lt;p&gt;User-Agent：产生请求的浏览器类型。&lt;/p&gt;
&lt;p&gt;Accept：客户端可识别的内容类型列表。&lt;/p&gt;
&lt;p&gt;Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.空行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.请求数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的&lt;strong&gt;请求头是Content-Type和Content-Length。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;GET /search?hl=zh-CN&amp;amp;source=hp&amp;amp;q=domety&amp;amp;aq=f&amp;amp;oq= HTTP/1.1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, application/x-silverlight, application/x-shockwave-flash, */*
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Referer: &amp;lt;a href=&amp;#34;http://www.google.cn/&amp;#34;&amp;gt;http://www.google.cn/&amp;lt;/a&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Accept-Language: zh-cn
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Accept-Encoding: gzip, deflate
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Host: &amp;lt;a href=&amp;#34;http://www.google.cn&amp;#34;&amp;gt;www.google.cn&amp;lt;/a&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Connection: Keep-Alive
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;POST /search HTTP/1.1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, application/x-silverlight, application/x-shockwave-flash, */*
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Referer: &amp;lt;a href=&amp;#34;http://www.google.cn/&amp;#34;&amp;gt;http://www.google.cn/&amp;lt;/a&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Accept-Language: zh-cn
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Accept-Encoding: gzip, deflate
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Host: &amp;lt;a href=&amp;#34;http://www.google.cn&amp;#34;&amp;gt;www.google.cn&amp;lt;/a&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Connection: Keep-Alive
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-FxlRugatx63JLv7CWMD6UB_O_r
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hl=zh-CN&amp;amp;source=hp&amp;amp;q=domety
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;http报文&#34;&gt;HTTP报文
&lt;/h3&gt;&lt;p&gt;HTTP响应也由三个部分组成，分别是：&lt;strong&gt;状态行、消息报头、响应正文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;正如你所见，在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个&lt;strong&gt;状态码&lt;/strong&gt;来说明所请求的资源情况。&lt;/p&gt;
&lt;p&gt;状态行格式如下：&lt;/p&gt;
&lt;p&gt;HTTP-Version Status-Code Reason-Phrase CRLF&lt;/p&gt;
&lt;p&gt;其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。&lt;/p&gt;
&lt;p&gt;状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1xx：指示信息–表示请求已接收，继续处理。&lt;/li&gt;
&lt;li&gt;2xx：成功–表示请求已被成功接收、理解、接受。&lt;/li&gt;
&lt;li&gt;3xx：重定向–要完成请求必须进行更进一步的操作。&lt;/li&gt;
&lt;li&gt;4xx：客户端错误–请求有语法错误或请求无法实现。&lt;/li&gt;
&lt;li&gt;5xx：服务器端错误–服务器未能实现合法的请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HTTP/1.1 200 OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Date: Sat, 31 Dec 2005 23:59:59 GMT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Type: text/html;charset=ISO-8859-1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Length: 122
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;＜html＞
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;＜head＞
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;＜title＞Wrox Homepage＜/title＞
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;＜/head＞
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;＜body＞
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;＜!-- body goes here --＞
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;＜/body＞
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;＜/html＞
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;78-代理服务器的工作原理是怎样的代理和网关有什么区别&#34;&gt;7.8 代理服务器的工作原理是怎样的？代理和网关有什么区别？
&lt;/h2&gt;&lt;p&gt;代理服务器和网关都会把&lt;strong&gt;网络内部的数据的数据发送到因特网上&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果把网关比&lt;strong&gt;作一扇通向因特网的门&lt;/strong&gt;，代理服务器&lt;strong&gt;就是一堵墙&lt;/strong&gt;，能够避免暴露网络内部的一些重要信息。&lt;/p&gt;
&lt;p&gt;代理服务器会&lt;strong&gt;过滤一些网络连接，只允许那些可以访问的通过&lt;/strong&gt;。而&lt;strong&gt;网关却不做任何的过滤。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网关：&lt;/p&gt;
&lt;p&gt;如果两个网络要进行通讯，那么&lt;strong&gt;每个网络都需要一个网关&lt;/strong&gt;。网关区分了一个网络的内部和外部。&lt;strong&gt;如果一台电脑需要访问网络外的其他电脑，那么就需要配置网关来获得访问网络外部的权限&lt;/strong&gt;。如果没有网关，电脑就无法访问局域网之外的网络部分，就像是被锁在家里一样。&lt;/p&gt;
&lt;p&gt;代理服务器：&lt;/p&gt;
&lt;p&gt;对于网络外部来说，&lt;strong&gt;代理服务器代表了整个内部网络&lt;/strong&gt;。任何用户想访问带有代理服务器的网络，&lt;strong&gt;都只能看到代理服务器的IP&lt;/strong&gt;。当把电脑的Internet选项配置成通过代理服务器访问因特网，&lt;strong&gt;代理服务器就能隐藏你的网络信息。它使网络内部的电脑变成匿名的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;功能区别：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果代理服务器不做任何信息过滤，那么它就和网关一样&lt;/strong&gt;，传递从电脑到因特网的请求。&lt;/p&gt;
&lt;p&gt;然后代理服务器是一个比网关更强大的网络组建，除了有网关的功能之外，&lt;strong&gt;还能保护网络免受外部的威胁&lt;/strong&gt;。&lt;strong&gt;网关却有暴露网络内部信息的危险，因为它没有任何过滤机制。它仅仅把网络内的信息发送到网络外。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;屏蔽网站：&lt;/p&gt;
&lt;p&gt;网关不能屏蔽网站。只要网关配置正确，电脑就能&lt;strong&gt;从网络内部访问因特网上的任何网站&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;代理服务器能把网络请求重定向到网络内部的网站上，从而&lt;strong&gt;屏蔽网站&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;管理员可以设置在某个时段或者全天时间屏蔽一些网站。&lt;strong&gt;访问这些被屏蔽的网站会重定向到特定的网站上&lt;/strong&gt;，表示你试图访问一个被屏蔽的网站。&lt;/p&gt;
&lt;p&gt;其他代理服务器的功能：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理服务器也能缓存一些电脑经常访问的网站&lt;/strong&gt;。它能跟踪网站点击量并使用这些信息储存每天访问的网站信息。当你第二次访问你之前访问过的网站时，代理服务器会返回缓存中的网站信息，而不会访问因特网。这个功能可以有效的减少访问外部网络的流量，节省带宽资源。可以设置每天几次获取因特网的新内容来刷新代理服务器的缓存信息。&lt;/p&gt;
&lt;p&gt;在HTTP通信链上，客户端和目标服务器之间通常存在某些**中转代理服务器，**它们提供对目标资源的中转访问。’&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个HTTP请求可能被多个代理服务器转发&lt;/strong&gt;，后面的服务器称为&lt;strong&gt;前面服务器的上游服务器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;代理服务器按照其使用方式和作用，分为&lt;strong&gt;正向代理服务器，反向代理服务器和透明代理服务器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正向代理要求客户端自己设置代理服务器的地址。客户的每次请求都将直接发送到该代理服务器，并由代理服务器来请求目标资源&lt;/strong&gt;。比如处于防火墙内的局域网机器要访问Internet，或者要访问一些被屏蔽掉的国外网站，就需要使用&lt;strong&gt;正向代理服务器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;反向代理则被设置在服务器端，因而客户端无需进行任何设置。&lt;strong&gt;反向代理是指用代理服务器来接收Internet上的连&lt;/strong&gt;接请求，&lt;strong&gt;然后将请求转发给内部网络上的服务器&lt;/strong&gt;，并将从&lt;strong&gt;内部服务器上得到的结果返回给客户端。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种情况下，&lt;strong&gt;代理服务器对外就表现为一个真实的服务器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;各大网站通常分区域设置了多个代理服务器，所以在&lt;strong&gt;不同的地方ping同一个域名可能得到不同的IP地址，因为这些IP地址实际上是代理服务器的IP地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20190529223536806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDkxMzcz,size_16,color_FFFFFF,t_70&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如图所示，正向代理服务器和客户端主机处于同一个逻辑网络中。&lt;strong&gt;该逻辑网络可以是一个本地LAN，也可以是一个更大的网络&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;反向代理服务器和真正的Web服务器也位于同一个逻辑网络中**，这通常由提供网站的公司来配置和管理。**&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;透明代理只能设置在网关上&lt;/strong&gt;。用户访问Internet的数据报必然都经过网关，如果在网关上设置代理，则该代理对用户来说显然是透明的。&lt;strong&gt;透明代理可以看作正向代理的一种特殊情况。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代理服务器通常还提供缓存目标资源的功能&lt;/strong&gt;，这样用户下次访问同一资源时速度将很快。&lt;strong&gt;优秀的开源软件squid，varnish都是提供了缓存能力的代理服务器软件&lt;/strong&gt;，其中squid支持所有代理方式，而varnish仅能用作反向代理。&lt;/p&gt;
&lt;h2 id=&#34;79-浏览器输入百度httpswwwnowcodercomjumpsuper-jumpwordworde799bee5baa6地址中间具体访问过程是怎么样的&#34;&gt;7.9 浏览器输入&lt;a class=&#34;link&#34; href=&#34;https://www.nowcoder.com/jump/super-jump/word?word=%E7%99%BE%E5%BA%A6&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;百度&lt;/a&gt;地址，中间具体访问过程是怎么样的？
&lt;/h2&gt;&lt;p&gt;1.客户端浏览器获取用户在地址栏输入的域名,&lt;strong&gt;URL解析&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2.客户端浏览器将域名发送给DNS域名系统，请求解析,&lt;strong&gt;DNS解析&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;3.DNS解析域名得到相应的IP，&lt;strong&gt;返回给客户端浏览器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;4.客户端浏览器根据IP向服务器发起TCP三次握手，建立&lt;strong&gt;TCP连接&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;5.客户端浏览器向服务器发送&lt;strong&gt;HTTP请求&lt;/strong&gt;，请求百度首页。&lt;/p&gt;
&lt;p&gt;6.服务器通过&lt;strong&gt;HTTP响应向客户端浏览器返回百度首页文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;7.&lt;strong&gt;释放TCP连接&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;8.客户端浏览器&lt;strong&gt;解析HTML文件&lt;/strong&gt;，根据文件内容获取CSS、JS等资源文件，将页面渲染展示给用户。&lt;/p&gt;
&lt;h2 id=&#34;710-网卡-网桥网关路由器交换机&#34;&gt;7.10 网卡 网桥，网关，路由器，交换机
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;路由器&lt;/strong&gt;可以根据&lt;strong&gt;IP地址&lt;/strong&gt;寻找下一个设备，可以处理&lt;strong&gt;TCPIP协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交换机是根据MAC地址寻址的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路由器是用于在&lt;strong&gt;不同网段之间&lt;/strong&gt;转发数据 （网络层）&lt;/p&gt;
&lt;p&gt;二层交换机是用于在&lt;strong&gt;同网段&lt;/strong&gt;转发数据 （&lt;strong&gt;数据链路层&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;三层交换机是可以在&lt;strong&gt;不同网段转发数据但在同网段转发数据能力特别强的交换机&lt;/strong&gt; 即可理解为路由器➕交换机（网络层）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个网关可以是路由器 可以是三层交换机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交换机是分配网络数据&lt;/strong&gt;，路由器可以给网络分配IP地址，分配给你地址而且可以随时通过地址过来找到你。&lt;/p&gt;
&lt;p&gt;路由器可以在不同时间内把一个IP分配给多台主机使用。&lt;/p&gt;
&lt;p&gt;交换机是通过&lt;strong&gt;MAC地址&lt;/strong&gt;和识别各个不同的主机。&lt;strong&gt;工作在OSI第二层（数据链路层）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、中继器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中继器（Repeater）工作于OSI的第一层（物理层），中继器是最简单的网络互联设备，连接同一个网络的两个或多个网段，主要完成物理层的功能，负责在两个网络节点的物理层上按位传递信息&lt;/strong&gt;，完成信号的复制、调整和放大功能，以此从而增加信号传输的距离，延长网络的长度和覆盖区域，支持远距离的通信。&lt;/p&gt;
&lt;p&gt;一般来说，中继器两端的网络部分是网段，而不是子网。中继器只将任何电缆段上的数据发送到另一段电缆上，并不管数据中是否有错误数据或不适于网段的数据。大家最常接触的是网络中继器，在通讯上还有微波中继器、激光中继器、红外中继器等等，机理类似，触类旁通。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、集线器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集线器也称HUB，工作在OSI七层结构的第一层物理层，属于共享型设备，接收数据广播发出，在局域网内一般都是星型连接拓扑结构，每台工作站都连接到集线器上&lt;/strong&gt;。由于集线器的带宽共享特性导致网络利用效率极低，一般在大中型的网络中不会使用到集线器。现在的集线器基本都是全双工模式，市面上常见的集线器传输速率普遍都为100Mbps。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、网桥&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网桥和交换机一样都是工作在OSI模型的第二层（数据链路层）&lt;/strong&gt;，可以看成是一个二层路由器（真正的路由器是工作在网络层，根据IP地址进行信包转发）。&lt;/p&gt;
&lt;p&gt;网桥&lt;strong&gt;可有效的将两个局域网（LAN）连起来，根据MAC地址（物理地址）来转发帧&lt;/strong&gt;，使本地通信限制在本网段内，并转发相应的信号至另一网段，网桥通常用于联接数量不多的、同一类型的网段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、交换机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;交换机顾名思义以交换为主要功能，工作在OSI第二层（数据链路层），&lt;strong&gt;根据MAC地址进行数据转发&lt;/strong&gt;。交换机的&lt;strong&gt;每一个端口都属于一个冲突域&lt;/strong&gt;，而集线器&lt;strong&gt;所有端口属于一个冲突域&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;交换机通过分析Ethernet包的包头信息（其中包含了源MAC地址、目标MAC地址、信息长度等），取得目标MAC地址后，查找交换机中存储的地址对照表（MAC地址对应的端口），&lt;strong&gt;确认具有此MAC地址的网卡连接在哪个端口上&lt;/strong&gt;，然后将&lt;strong&gt;信包送到对应端口&lt;/strong&gt;，有效的抑制IP广播风暴。并且信息包处于并行状态，效率较高。&lt;/p&gt;
&lt;p&gt;数据包通过交换机转发抵达了路由器，准备要离开土生土长的子网了。此时，数据包和交换机离别时说道：“感谢交换机兄弟，帮我转发到出境的大门，我要出远门啦！”&lt;/p&gt;
&lt;p&gt;交换机的转发延迟非常小，主要的得益于其硬件设计机理非常高效，为了&lt;strong&gt;支持各端口的最&lt;a class=&#34;link&#34; href=&#34;http://lib.csdn.net/base/20&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;大数据&lt;/a&gt;传输速率&lt;/strong&gt;，交换&lt;strong&gt;机内部转发信包的背板带宽都必须远大于端口带宽&lt;/strong&gt;，具有强&lt;strong&gt;大的整体吞吐率&lt;/strong&gt;，才能为每台工作站提供更高的带宽和更高的网络利用率，可以满足大型网络环境大量数据并行处理的要求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、路由器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路由器跟集线器和交换机不同，是工作在OSI的第三层（网络层），&lt;strong&gt;根据IP进行寻址转发数据包&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路由器是一种可以连接多个网络或网段的网络设备，能将不同网络或网段之间（比如局域网——大网）的数据信息进行转换&lt;/strong&gt;，并为信包传输分配最合适的路径，使它们之间能够进行数据传输，从而构成一个更大的网络。&lt;/p&gt;
&lt;p&gt;路由器具有最主要的两个功能，即&lt;strong&gt;数据通道功能和控制功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数据通道功能包括&lt;strong&gt;转发决定、背板转发以及输出链路调度等，一般由特定的硬件来完成；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制功能一般用软件来实现&lt;/strong&gt;，包括与相邻路由器之间的信息交换、系统配置、系统管理等。实在找&lt;strong&gt;不到匹配路由时，就会选择默认路由&lt;/strong&gt;，路由表中子网掩码为 &lt;code&gt;0.0.0.0&lt;/code&gt; 的记录表示「默认路由」。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六、网关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网关（Gateway）又叫协议转换器，网关是一种复杂的网络连接设备，可以支持不同协议之间的转换，&lt;strong&gt;实现不同协议网络之间的互连&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在网络中，路由器为第三层网络层设备，其主要功能是根&lt;strong&gt;据最佳路由把数据包转发到下一站&lt;/strong&gt;，实现从源IP到目标IP的端到端数据传输服务；&lt;/li&gt;
&lt;li&gt;网&lt;strong&gt;关早期的时候就是路由器的别名&lt;/strong&gt;，但是在&lt;strong&gt;现在的网络模型中把它归为应用层设备&lt;/strong&gt;。主要功能是&lt;strong&gt;过滤数据包信息以实现相应的功能&lt;/strong&gt;网关的概念实际上跟上面的设备型不是一类问题，但是为了方便参考还是放到这里一并介绍。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;网关具有对不兼容的高层协议进行转换的能力，为了实现异构设备之间的通信，网关需要对不同的链路层、专用会话层、表示层和应用层协议进行翻译和转换。所以&lt;strong&gt;网关兼有路由器、网桥、中继器的特性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若要使两个完全不同的网络（异构网）连接在一起，一般使用网关，&lt;strong&gt;在Internet中两个网络也要通过一台称为网关的计算机实现互联&lt;/strong&gt;。这台计算机能根据用户通信目标计算机的IP地址，决定是否将用户发出的信息送出本地网络，同时，它还将外界发送给属于本地网络计算机的信息接收过来，它是一个网络与另一个网络相联的通道。为了使TCP/IP协议能够寻址，该通道被赋予一个IP地址，这个IP地址称为网关地址。&lt;/p&gt;
&lt;p&gt;所以，网关的作用就是将两个使用不同协议的网络段连接在一起的设备，&lt;strong&gt;对两个网络段中的使用不同传输协议的数据进行互相的翻译转换&lt;/strong&gt;。在互连设备中，由于协议转换的复杂性，一般只能进行一对一的转换，或是少数几种特定应用协议的转换。&lt;/p&gt;
&lt;p&gt;网卡：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，我们需要将&lt;strong&gt;数字信息转换为电信号&lt;/strong&gt;，才能在网线上传输，也就是说，这才是真正的数据发送过程。负责执行这一操作的是&lt;strong&gt;网卡&lt;/strong&gt;，要控制网卡还需要靠&lt;strong&gt;网卡驱动程序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;网卡驱动获取网络包之后，会将其&lt;strong&gt;复制&lt;/strong&gt;到网卡内的缓存区中，接着会在其&lt;strong&gt;开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最后网卡会将包转为电信号，通过网线发送出去。&lt;/p&gt;
&lt;h2 id=&#34;网关和路由器区别&#34;&gt;网关和路由器区别：
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1、本质区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网关这种设备它主要是用&lt;strong&gt;来连接两种不同的网络&lt;/strong&gt;，同时，网关它还能够同时&lt;strong&gt;与两边的主机之间进行通信。但是两边的主机是不能够直接进行通信，是必须要经过网关才能进行通信。网关的工作是在应用层当中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路由器它是属于&lt;strong&gt;网络层设备&lt;/strong&gt;，通常是以包为单位进行数据的发送。&lt;/p&gt;
&lt;p&gt;在路由器的子接口，是有分割广播域的作用，所以当我们用&lt;strong&gt;交换机做VLAN以后，都是要在路由器上做一个三层的路由。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、使用方式的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网关它可以是路由器，交换机或者是PC。在同一网段之内进行通信，是不需要将网关介入其中，只有当主机个非本网段设备进行通信的时候，才需要将数据包全部发给网关设备，再经由网关设备进行转发或者是有路由处理等。&lt;/p&gt;
&lt;p&gt;路由器它是一个网络层系统，路由器在现在市场上一般是被分成了两大类，一类是单协议路由器，另一类是多协议路由器。路由器它可以进行数据格式的转换，成为不同&lt;strong&gt;于协议之间的网络互连的必要设备。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、功能上的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网关可以分为传输型网关和应用型网关，它的功能是充当转换重任，实质上就是一个网络通向其他网络的IP地址。&lt;/p&gt;
&lt;p&gt;路由器的功能主要有：连通不同的网络和信息传输作用。按照使用可分为：接入、企业级、骨干级、太比特、多WAN以及3G无线等。&lt;/p&gt;
&lt;h2 id=&#34;711-http缓存技术&#34;&gt;7.11 HTTP缓存技术
&lt;/h2&gt;&lt;p&gt;HTTP 缓存有两种实现方式，分别是&lt;strong&gt;强制缓存和协商缓存&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;强制缓存&#34;&gt;强制缓存
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图中，返回的是 200 状态码，&lt;strong&gt;但在 size 项中标识的是 from disk cache，就是使用了强制缓存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/1cb6bc37597e4af8adfef412bfc57a42.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Cache-Control&lt;/code&gt;， 是一个相对时间；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expires&lt;/code&gt;，是一个绝对时间；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，&lt;strong&gt;Cache-Control的优先级高于 Expires&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存&lt;/strong&gt;。具体的实现流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；&lt;/li&gt;
&lt;li&gt;浏览器再次请求访问服务器中的该资源时，会先&lt;strong&gt;通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期&lt;/strong&gt;，如果没有，则使用该缓存，否则重新请求服务器；&lt;/li&gt;
&lt;li&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;服务器再次收到请求后，会&lt;strong&gt;再次更新 Response 头部的 Cache-Control。&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;协商缓存&#34;&gt;协商缓存
&lt;/h3&gt;&lt;p&gt;当我们在浏览器使用开发者工具的时候，你可能会看到过某些&lt;strong&gt;请求的响应码是 &lt;code&gt;304&lt;/code&gt;&lt;/strong&gt;，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上图就是一个协商缓存的过程，所以&lt;strong&gt;协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;协商缓存可以基于两种头部来实现。&lt;/p&gt;
&lt;p&gt;第一种：请求头部中的 &lt;strong&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt; 字段&lt;/strong&gt;与&lt;strong&gt;响应头部中的 &lt;code&gt;Last-Modified&lt;/code&gt;&lt;/strong&gt; 字段实现，这两个字段的意思是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应头部中的 &lt;code&gt;Last-Modified&lt;/code&gt;：&lt;strong&gt;标示这个响应资源的最后修改时间&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;请求头部中的 &lt;code&gt;If-Modified-Since&lt;/code&gt;：当资源过期了，&lt;strong&gt;发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间&lt;/strong&gt;，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，**HTTP 200 OK；**如果最后修改时间较旧（小），说明资源无新修改，&lt;strong&gt;响应 HTTP 304 走缓存。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二种：请求头部中的 &lt;strong&gt;&lt;code&gt;If-None-Match&lt;/code&gt; 字段与响应头部中的 &lt;code&gt;ETag&lt;/code&gt; 字段&lt;/strong&gt;，这两个字段的意思是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应头部中 &lt;code&gt;Etag&lt;/code&gt;：唯一标识响应资源；&lt;/li&gt;
&lt;li&gt;请求头部中的 &lt;code&gt;If-None-Match&lt;/code&gt;：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，&lt;strong&gt;会将请求头If-None-Match 值设置为 Etag 的值&lt;/strong&gt;。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第一种实现方式是基于时间实现的&lt;/strong&gt;，第二种&lt;strong&gt;实现方式是基于一个唯一标识实现的&lt;/strong&gt;，相对来说&lt;strong&gt;后者可以更加准确地判断文件内容是否被修改&lt;/strong&gt;，避免&lt;strong&gt;由于时间篡改导致的不可靠问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候， &lt;strong&gt;Etag 的优先级更高&lt;/strong&gt;，也就是先会判断 Etag 是否变化了，如果 Etag 没有变化，然后再看 Last-Modified。&lt;/p&gt;
&lt;p&gt;注意，&lt;strong&gt;协商缓存这两个字段都需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/d92026ce085b401c95cf02b7ce9b7fae.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;使用 ETag 字段实现的协商缓存的过程如下；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，&lt;strong&gt;在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期，如果没有过期，则直接使用本地缓存&lt;/strong&gt;；如果缓存过期了，&lt;strong&gt;会在 Request 头部加上 If-None-Match 字段&lt;/strong&gt;，该字段的值就是 ETag 唯一标识；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器再次收到请求后，&lt;/p&gt;
&lt;p&gt;会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果值相等，则返回 304 Not Modified，不会返回资源&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果浏&lt;strong&gt;览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cde24490-d47b-49ae-b566-abdfe80c2328/Untitled.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Untitled&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>计算机网络常见问题2</title>
        <link>https://Salmooo.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%982/</link>
        <pubDate>Mon, 18 Nov 2019 21:45:27 +0800</pubDate>
        
        <guid>https://Salmooo.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%982/</guid>
        <description>&lt;h3 id=&#34;1-对路由协议的了解与介绍内部网关协议igp包括ripospf和外部网关协议egp和bgp&#34;&gt;&lt;strong&gt;1. 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP.&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A&lt;/p&gt;
&lt;p&gt;路由协议是指在计算机网络中用于确定数据包如何从源节点传输到目标节点的规则集合。常见的路由协议包括内部网关协议（IGP）和外部网关协议（EGP）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;内部网关协议（IGP）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RIP（路由信息协议）&lt;/strong&gt;：RIP是一种基于距离向量的路由协议，使用跳数作为度量标准。每隔一段时间，路由器会向相邻路由器发送路由更新信息。RIP“路由信息协议(Route Information Protocol)”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息。RIP是一个距离矢量路由协议,最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OSPF（开放最短路径优先）&lt;/strong&gt;：OSPF是一种基于链路状态的路由协议，使用最短路径优先算法（Dijkstra算法）计算最佳路由。OSPF支持VLSM（可变长度子网掩码）和路由聚合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外部网关协议（EGP）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;EGP（外部网关协议）&lt;/strong&gt;：EGP是一种早期的外部网关协议，已经不再广泛使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BGP（边界网关协议）&lt;/strong&gt;：BGP是一种路径矢量协议，用于在不同自治系统之间交换路由信息。BGP是互联网核心路由协议，负责在全球范围内的路由选择。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些协议在计算机网络中起着至关重要的作用，帮助数据包在网络中正确快速地传&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;udp如何实现可靠传输&#34;&gt;&lt;strong&gt;UDP如何实现可靠传输&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq/ack机制，重传机制和窗口确认机制。&lt;/p&gt;
&lt;p&gt;就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。&lt;/p&gt;
&lt;h3 id=&#34;2-流量控制的介绍采用滑动窗口会有什么问题死锁可能糊涂窗口综合征&#34;&gt;&lt;strong&gt;2. 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用TCP报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。&lt;/p&gt;
&lt;p&gt;考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。&lt;/p&gt;
&lt;p&gt;解决这个问题，&lt;strong&gt;TCP为每一个连接设置一个持续计时器（persistence timer）&lt;/strong&gt;。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。&lt;/p&gt;
&lt;h3 id=&#34;3-一个机器能够使用的端口号上限是多少为什么可以改变吗那如果想要用的端口超过这个限制怎么办&#34;&gt;&lt;strong&gt;3. 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;因为TCP的报文头部中&lt;strong&gt;源端口号和目的端口号的长度是16位&lt;/strong&gt;，也就是可以表示2^16=65536个&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不同端口号，因此TCP可供识别的端口号最多只有65536个。&lt;strong&gt;但是由于0到1023是知名服务端口&lt;/strong&gt;，所以实际上还要少1024个端口号。&lt;/p&gt;
&lt;p&gt;而对于服务器来说，&lt;strong&gt;可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量&lt;/strong&gt;，并且可以通过&lt;strong&gt;MaxUserPort来进行配置&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;4--对称密码和非对称密码体系&#34;&gt;&lt;strong&gt;4.  对称密码和非对称密码体系&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_29689487/article/details/81634057&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/qq_29689487/article/details/81634057&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对称加密：加密和解密使用的密钥是同一个
&lt;ul&gt;
&lt;li&gt;优点：计算量小，算法速度快，加密效率高&lt;/li&gt;
&lt;li&gt;缺点：密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲&lt;/li&gt;
&lt;li&gt;常用算法：&lt;strong&gt;DES，3DES，IDEA，CR4，CR5，CR6，AES&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;非对称加密：需要公钥和私钥，公钥用来加密，私钥用来解密
&lt;ul&gt;
&lt;li&gt;优点：&lt;strong&gt;安全，不怕泄漏&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：速度慢&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;常用算法：&lt;strong&gt;RSA，ECC，DSA&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5--数字证书的了解高频&#34;&gt;&lt;strong&gt;5.  数字证书的了解（高频）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9qaWFudHVrdS1saXdlbmJpbi5vc3MtY24tc2hhbmdoYWkuYWxpeXVuY3MuY29tLyVFOSU5RCVBMiVFNyVCQiU4RiVFNSU5MCU4OCVFOSU5QiU4Ni8lRTYlOTUlQjAlRTUlQUQlOTclRTglQUYlODElRTQlQjklQTYuanBn?x-oss-process=image/format,png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;权威CA使用**私钥将网站A的信息和消息摘要（签名S）**进行加密打包形成数字证书。&lt;/p&gt;
&lt;p&gt;公钥给客户端。&lt;/p&gt;
&lt;p&gt;网站A将自己的&lt;strong&gt;信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密&lt;/strong&gt;，得到签名S，与&lt;strong&gt;手动将网站的信息进行消息摘要&lt;/strong&gt;得到的结果S*进行对比，如果签名一致就证明网站A可以信任。&lt;/p&gt;
&lt;h3 id=&#34;6-消息摘要算法列举一下介绍md5算法为什么md5是不可逆的有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢百度安全一面&#34;&gt;&lt;strong&gt;6. 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MD5算法介绍：&lt;/p&gt;
&lt;p&gt;MD5以512位分组来处理输入的信息，且每一分组又被划分为若干个小分组（16个32位子分组），经过一些列的处理后，&lt;strong&gt;算法输出由四个散列值&lt;/strong&gt;（32位分组组成的128位散列值。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;MD5首先将输入的信息分成若干个512字节长度的分组，如果&lt;strong&gt;不够就填充1和若干个0。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对每个512字节的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量。&lt;/li&gt;
&lt;li&gt;接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量，重复16次这个过程，得到的四个变量作为幻数，与下一个分组进行相似的计算。&lt;/li&gt;
&lt;li&gt;遍历所有分组后得到的四个变量即为结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;详见：https://blog.csdn.net/weixin_39640298/article/details/84555814&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么不可逆：因为MD5在进行消息摘要的过程中，&lt;strong&gt;数据与原始数据相比发生了丢失&lt;/strong&gt;，所以不能由结果进行恢复。&lt;/li&gt;
&lt;li&gt;加强安全性：&lt;strong&gt;加盐（加随机数）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-单条记录高并发访问的优化&#34;&gt;&lt;strong&gt;7. 单条记录高并发访问的优化&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;服务器端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用缓存，如redis&lt;/strong&gt;等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用分布式架&lt;/strong&gt;构进行处理&lt;/li&gt;
&lt;li&gt;将静态页面和静态&lt;strong&gt;资源存储在静态资源服务器&lt;/strong&gt;，需要处理的数据&lt;strong&gt;使用服务器进行计算后返回&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将&lt;strong&gt;静态资源尽可能在客户端进行缓存&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;采用&lt;strong&gt;ngnix进行负载均衡&lt;/strong&gt; （nginx读作恩静埃克斯 = &lt;strong&gt;Engine X&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据库端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库&lt;strong&gt;采用主从赋值&lt;/strong&gt;，&lt;strong&gt;读写分离措施&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;建立&lt;strong&gt;适当的索引&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分库分表&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;8--介绍一下ping的过程分别用到了哪些协议-百度安全等&#34;&gt;&lt;strong&gt;8.  介绍一下ping的过程，分别用到了哪些协议 （百度安全等）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;详见：&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Ping原理与ICMP协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ping是使用ICMP协议来进行工作的。 ICMP:网络控制报文协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，ping命令会构建一个ICMP请求数据包，然后由&lt;strong&gt;ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后IP协议就会构建一个IP数据报，并且&lt;strong&gt;在映射表中查找目的IP对应的mac地址&lt;/strong&gt;，将其交给数据&lt;strong&gt;链路层。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;然后数据链路层就会构建一个数据帧，附上&lt;strong&gt;源mac地址和目的mac地址发送出&lt;/strong&gt;去。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，&lt;strong&gt;就接收并把其中的信息提取出来交给IP协议&lt;/strong&gt;，IP协议就会&lt;strong&gt;将其中的信息提取出来交给ICMP协议&lt;/strong&gt;。然后构建一个ICMP应答包，&lt;strong&gt;用相同的过程发送回&lt;/strong&gt;去。&lt;/p&gt;
&lt;h3 id=&#34;9--tcpip的粘包与避免介绍一下&#34;&gt;&lt;strong&gt;9.  TCP/IP的粘包与避免介绍一下&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;因为TCP为了减少额外开销，采取的是流式传输，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。&lt;/p&gt;
&lt;p&gt;导致TCP粘包的原因有三方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;发送端等待缓冲区满才进行发送，造成粘包&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接收方来不及接收缓冲区内的数据，造成粘包&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;由于TCP协议在&lt;strong&gt;发送较小的数据包的时候&lt;/strong&gt;，会将&lt;strong&gt;几个包合成一个包后发送&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;避免粘包的措施：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过编程，&lt;strong&gt;强制使TCP发生数据传送&lt;/strong&gt;，不必&lt;strong&gt;等到缓冲区满&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;优化接收方接收数据的过程，使其&lt;strong&gt;来得及接收数据包，&lt;strong&gt;包括提高接&lt;/strong&gt;收进程优先级&lt;/strong&gt;等&lt;/li&gt;
&lt;li&gt;设置&lt;strong&gt;固定长度的报文&lt;/strong&gt; 或者 &lt;strong&gt;设置报文头部指示报文的长度&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;10-说一下tcp的封包和拆包&#34;&gt;&lt;strong&gt;10. 说一下TCP的封包和拆包&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封包：封包就是在发送数据报的时候为&lt;strong&gt;每个TCP数据包加上一个包头&lt;/strong&gt;，将数据报分为包头和包体两个部分。&lt;strong&gt;包头是一个固定长度的结构体，里面包含该数据包的总长度。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;拆包：接收方在接收到报文后&lt;strong&gt;提取包头中的长度信息进行截取。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>计算机网络学习小结</title>
        <link>https://Salmooo.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</link>
        <pubDate>Wed, 16 Oct 2019 19:32:27 +0800</pubDate>
        
        <guid>https://Salmooo.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</guid>
        <description>&lt;p&gt;#1. 网络结构&lt;/p&gt;
&lt;h2 id=&#34;11-计算机网络结构&#34;&gt;1.1 计算机网络结构？
&lt;/h2&gt;&lt;p&gt;计算机网络一共有3种模型。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OSI七层结构&lt;/li&gt;
&lt;li&gt;TCP/IP结构&lt;/li&gt;
&lt;li&gt;五层协议结构&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216134035.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSI是Open Systems Interconnect&lt;/strong&gt;，也就是开放的互联系统，将复杂的互联网系统划分为不同块，方便处理。&lt;/p&gt;
&lt;p&gt;实际应用中，并没有采用这个理论模型，而是使用TCP/IP协议的四层模型。&lt;/p&gt;
&lt;p&gt;而5层模型是一个理论上的网络通信模型，方便教学的时候理解，实际上并不存在。&lt;/p&gt;
&lt;h2 id=&#34;12-计算机网络中各层作用&#34;&gt;1.2 计算机网络中各层作用
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6266643a-3e0e-4338-b94d-4017814417bf/Untitled.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Untitled&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）应用层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用层的任务是通过应用进程间的交互来完成特定网络应用，访问OSI环境的手段&lt;/strong&gt;，应用层协议定义的是应用进程（进程:主机中正在运行的程序）间的通信和交互的规则。&lt;/p&gt;
&lt;p&gt;常见的协议有&lt;strong&gt;域名系统DNS&lt;/strong&gt;，万维网应用的&lt;strong&gt;HTTP协议&lt;/strong&gt;，支持&lt;strong&gt;电子邮件的SMTP协议&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。&lt;/p&gt;
&lt;p&gt;把&lt;strong&gt;应用层交互的数据单元&lt;/strong&gt;称为&lt;strong&gt;报文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）运输层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为两台主机进程之间的通信提供**通用的数据传输服务，端对端的可靠报文传递和错误恢复。**主要包含两种协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传输控制协议 TCP&lt;/strong&gt;（Transmisson Control Protocol）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向连接 面向字节流 可靠 传输慢 流量控制阻塞控制 1v1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;**面向连接（三次握手四次挥手）， 面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），可靠（握手、ACK和重传机制），传输慢，**有流量控制阻塞控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用户数据报协议 UDP&lt;/strong&gt;（User Datagram Protocol）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无连接，面向报文，不可靠尽最大可能交付，传输快，没有流量控制和拥塞控制，可1vn to nv1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无连接的，尽最大可能交付，不可靠，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部&lt;/strong&gt;） ，支持一对一、一对多、多对一和多对多的交互通信，传输快，没有流量控制拥塞控制。&lt;/p&gt;
&lt;p&gt;当然，&lt;strong&gt;UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以&lt;/strong&gt;，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 TCP 协议中，我们把每个分块称为一个 TCP 段（&lt;em&gt;TCP Segment&lt;/em&gt;）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是&lt;strong&gt;端口&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。&lt;/p&gt;
&lt;p&gt;而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）网络层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送，数据包传递与网际互连。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络层最常使用的是 IP 协议（&lt;em&gt;Internet Protocol&lt;/em&gt;），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（最大传输单元，Maximum Transmission Unit）以太网中一般为 1500 字节）就会&lt;strong&gt;再次进行分片&lt;/strong&gt;，得到一个即将发送到网络的 IP 报文。&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;IP协议&lt;/strong&gt;，ARP协议，IP协议，ICMP协议，IGMP协议等。&lt;/p&gt;
&lt;p&gt;网络层有两个任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把运输层产生的&lt;strong&gt;报文段&lt;/strong&gt;或用户数据报 &lt;strong&gt;封装成分组和包进行传送&lt;/strong&gt;。在 TCP/IP 体系结构中，由于网络层使用 &lt;strong&gt;IP 协议&lt;/strong&gt;，因此分组也叫 &lt;strong&gt;IP 数据报&lt;/strong&gt; ，简称 &lt;strong&gt;数据报&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;注意：不要把运输层的用户数据报UDP和网络层的IP数据报弄混。&lt;/li&gt;
&lt;li&gt;选择&lt;strong&gt;合适的路由，找到目的主机。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。&lt;/p&gt;
&lt;p&gt;我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。&lt;/p&gt;
&lt;p&gt;因此，需要将 IP 地址分成两种意义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是&lt;strong&gt;网络号&lt;/strong&gt;，负责标识该 IP 地址是属于哪个「子网」的；&lt;/li&gt;
&lt;li&gt;一个是&lt;strong&gt;主机号&lt;/strong&gt;，负责标识同一「子网」下的不同主机；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;（4）数据链路层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据链路层的任务是确保在直接相连的两个节点之间可靠地传输数据，并处理与物理层交互和链路管理相关的事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两台主机之间的数据传输，总是在&lt;strong&gt;一段一段的链路&lt;/strong&gt;上传送的，这就需要使用专门的链路层的协议。&lt;/p&gt;
&lt;p&gt;在两个相邻节点之间传送数据时，&lt;strong&gt;数据链路层将网络层交下来的 IP 数据报组装程帧&lt;/strong&gt;，在两个相邻节点间的链路上传送帧。&lt;/p&gt;
&lt;p&gt;主要协议：1、Point-to-Point Protocal——PPP点到点。2、Ethernet——以太网。3、High-Level Data Link Control Protocal——高级链路控制协议。4、Frame Relay——帧中继。5、Asynchronous Transfer Mode——异步传输模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）物理层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;物理层的任务就是&lt;strong&gt;透明地传输比特流&lt;/strong&gt;，尽可能屏蔽掉具体传输介质和物理设备的差异，确定电气规范，使其上面的数据链路层不必考虑网络的具体传输介质是什么。换句话说实际电路传送后比特流没有发生变化。&lt;/p&gt;
&lt;p&gt;Tips:&lt;/p&gt;
&lt;p&gt;网络接口层&lt;/p&gt;
&lt;p&gt;生成了 IP 头部之后，接下来要交给**网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，**并封装成数据帧（Data frame）发送到网络上。&lt;/p&gt;
&lt;p&gt;主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。&lt;/p&gt;
&lt;h1 id=&#34;2-tcpip协议&#34;&gt;2. TCP/IP协议
&lt;/h1&gt;&lt;h2 id=&#34;21-tcpip协议的结构&#34;&gt;2.1 TCP/IP协议的结构
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216134831.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://prod-files-secure.s3.us-west-2.amazonaws.com/55e47ff7-aae4-4da6-84db-815d6c9a8d65/bb471c0e-dc56-44d3-b972-2d88149a49cc/Untitled.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Untitled&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;-&lt;/p&gt;
&lt;p&gt;1、源端口号（Source Port）
16位的源端口字段包含初始化通信的端口号。源端口和IP地址的作用是标识报文的返回地址。&lt;/p&gt;
&lt;p&gt;2、目的端口号（Destination Port）
　16位的目的端口字段定义传输的目的。这个端口指明接收方计算机上的应用程序接口。&lt;/p&gt;
&lt;p&gt;3、序列号（Sequence Number）
该字段用来标识TCP源端设备向目的端设备发送的字节流，它表示在这个报文段中的第几个数据字节。序列号是一个32位的数。&lt;/p&gt;
&lt;p&gt;4、确认号（Acknowledge Number）
　　TCP使用32位的确认号字段标识期望收到的下一个段的第一个字节，并声明此前的所有数据已经正确无误地收到，因此，确认号应该是上次已成功收到的数据字节序列号加1。收到确认号的源计算机会知道特定的段已经被收到。确认号的字段只在ACK标志被设置时才有效。
5、首部长度
长度为4位，用于表示TCP报文首部的长度。用4位（bit）表示，十进制值就是[0,15]，一个TCP报文前20个字节是必有的，后40个字节根据情况可能有可能没有。如果TCP报文首部是20个字节，则该位应是20/4=5。
6、保留位（Reserved）
长度为6位，必须是0，它是为将来定义新用途保留的。
7、标志（Code Bits）
长度为6位，在TCP报文中不管是握手还是挥手还是传数据等，这6位标志都很重要。6位从左到右依次为：
1.
• URG：紧急标志位，说明紧急指针有效；
• ACK：确认标志位，多数情况下空，说明确认序号有效； 取1时表示应答字段有效，也即TCP应答号将包含在TCP段中，为0则反之。
• PSH：推标志位，置位时表示接收方应立即请求将报文交给应用层；
• RST：复位标志，用于重建一个已经混乱的连接，用来复位产生错误的连接，也会用来拒绝错误和非法的数据包。
• SYN：同步标志，该标志仅在三次握手建立TCP连接时有效
• FIN：结束标志，表示发送端已经发送到数据末尾，数据传送完成，发送FIN标志位的TCP段，连接将被断开。
8、窗口大小（Window Size）
长度为16位，TCP流量控制由连接的每一端通过声明的窗口大小来提供。
9、检验和（Checksum）
长度为16位，该字段覆盖整个TCP报文端，是个强制性的字段，是由发送端计算和存储，到接收端后，由接收端进行验证。
10、紧急指针（Urgent Pointer）
长度为16位，指向数据中优先部分的最后一个字节，通知接收方紧急数据的长度，该字段在URG标志置位时有效。
11、选项（Options）
长度为0-40B（字节），必须以4B为单位变化，必要时可以填充0。通常包含：最长报文大小（MaximumSegment Size，MSS）、窗口扩大选项、时间戳选项、选择性确认（Selective ACKnowlegement，SACK）等。
12、数据
可选报文段数据部分。&lt;/p&gt;
&lt;p&gt;-&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，&lt;strong&gt;源端口号&lt;/strong&gt;和&lt;strong&gt;目标端口&lt;/strong&gt;号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。&lt;/li&gt;
&lt;li&gt;接下来有包的&lt;strong&gt;序&lt;/strong&gt;号，这个是为了解决包乱序的问题。&lt;/li&gt;
&lt;li&gt;还有应该有的是&lt;strong&gt;确认号&lt;/strong&gt;，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是&lt;strong&gt;为了解决不丢包的问题&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;接下来还有一些&lt;strong&gt;状态位flag&lt;/strong&gt;。例如 &lt;code&gt;SYN&lt;/code&gt; 是发起一个连接，&lt;code&gt;ACK&lt;/code&gt; 是回复，&lt;code&gt;RST&lt;/code&gt; 是重新连接，&lt;code&gt;FIN&lt;/code&gt; 是结束连接等。  TCP 是面向连接的，&lt;strong&gt;因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;还有一个重要的就是&lt;strong&gt;窗口大小&lt;/strong&gt;。TCP 要做&lt;strong&gt;流量控制&lt;/strong&gt;，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。&lt;/li&gt;
&lt;li&gt;除了做流量控制以外，TCP还会做&lt;strong&gt;拥塞控制&lt;/strong&gt;，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;udp报头&#34;&gt;UDP报头
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://prod-files-secure.s3.us-west-2.amazonaws.com/55e47ff7-aae4-4da6-84db-815d6c9a8d65/0b2ea092-a08a-4264-bbe7-5e8107707be0/Untitled.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Untitled&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;-&lt;/p&gt;
&lt;p&gt;每个 UDP 报文分为 &lt;strong&gt;UDP 报头和 UDP 数据区&lt;/strong&gt;两部分。报头由 &lt;strong&gt;4 个 16 位长（2 字节）字段&lt;/strong&gt;组成，分别说明该报文的源端口、目的端口、报文长度和校验值。&lt;/p&gt;
&lt;p&gt;UDP 报文中每个字段的含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源端口：这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口。接收端的应用程序利用这个字段的值作为发送响应的目的地址。&lt;strong&gt;这个字段是可选的，所以发送端的应用程序不一定会把自己的端口号写入该字段中。如果不写入端口号，则把这个字段设置为 0。这样，接收端的应用程序就不能发送响应了。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;目的端口：接收端计算机上 &lt;strong&gt;UDP 软件使用的端口，占据 16 位。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;长度：该字段&lt;strong&gt;占据 16 位&lt;/strong&gt;，表示 UDP 数据报长度**，包含 UDP 报文头和 UDP 数据长度**。因为 &lt;strong&gt;UDP 报文头长度是 8 个字节，所以这个值最小为 8。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;校验值：&lt;strong&gt;该字段占据 16 位&lt;/strong&gt;，可以检验数据在&lt;strong&gt;传输过程中是否被损坏。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ip数据报的首部&#34;&gt;IP数据报的首部
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注：IP数据报的格式，能够说明IP协议都具有什么功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://img-blog.csdn.net/20160216233020326&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;-&lt;/p&gt;
&lt;h3 id=&#34;ip数据报首部固定部分&#34;&gt;IP数据报首部——固定部分
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1.1 版本&lt;/strong&gt; &lt;strong&gt;占4位，指IP协议的版本。&lt;/strong&gt; 通信双方使用的IP协议的版本必须一致。 &lt;strong&gt;IP协议版本号为4(即IPv4)，IP协议版本号为6(即IPv6)。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1.2 首部长度 占4位，可表示的最大十进制数值是15。&lt;/strong&gt; 这个字段所表示数的单位是32位字(&lt;strong&gt;即4字节&lt;/strong&gt;)，因此，当IP的首部长度为1111(即十进制的15)时，&lt;strong&gt;首部长度就达到最大值60个字节&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最常用的首部长度就是&lt;strong&gt;20个字节(即首部长度为0101&lt;/strong&gt;)，这时不使用任何选项，是固定首部的长度。 当IP分组的&lt;strong&gt;首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1.3 区分服务&lt;/strong&gt; &lt;strong&gt;占8位，用来获得更好的服务。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1.4 总长度&lt;/strong&gt; &lt;strong&gt;占16位，指首部和数据之和的长度。&lt;/strong&gt; 数据报的最大长度为&lt;strong&gt;2^16 -1 = 65535字节&lt;/strong&gt;。“MTU是Maximum Transmission Unit的缩写。意思是网络上传送的最大数据包&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;在IP层下面的每一种数据链路层都有其自己的帧格式，其中包括帧格式中的数据字段的最大长度，这称为最大传送单元MTU(Maximum Transfer Unit)。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;当一个IP数据报封装成数据链路层的帧时，此数据报的总长度(即首部加上数据部分)，一定不能**超过下面的数据链路层的MTU值。**
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;虽然使用尽可能长的数据报会使传输效率提高，但由于以太网的普遍应用，所以实际上使用的**数据报长度很少有超过1500字节的。**
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;为了不使IP数据报的传输效率降低，有关IP的标准文档规定，所有的**主机和路由器必须能够处理的IP数据报的长度不得少于576字节。这个数值也就是最小的IP数据报的总长度。**
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;当数据报长度超过网络所容许的最大传送单元MTU时，就必须把**过长的数据报进行分片后才能在网络上传送(“片偏移”字段相关)。**
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;这时，**数据报首部中的总长度不是指未分片前的数据报长度，而是指分片后的每一个分片的首部长度与数据长度的总和。**
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1.5 标识&lt;/strong&gt; &lt;strong&gt;占16位，指IP软件在存储器中维持一个计数器，每产生一个数据报&lt;/strong&gt;，&lt;strong&gt;计数器就加1&lt;/strong&gt;，并将此值付给标识字段。&lt;/p&gt;
&lt;p&gt;但这个&lt;strong&gt;标识并不是序号&lt;/strong&gt;，因为&lt;strong&gt;IP是无连接服务&lt;/strong&gt;，数据报不存在按序接收的问题。 当数据报由于&lt;strong&gt;长度超过网络的MTU而必须分片&lt;/strong&gt;时，这个标识字段的值就会被复制到所有的数据报片的标识字段中。相&lt;strong&gt;同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1.6 标志&lt;/strong&gt; &lt;strong&gt;占3位，但目前只有两位有意义。&lt;/strong&gt; 标志字段中的最低位记为MF(More Fragment)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) MF=1即表示后面“还有分片”的数据报。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)MF=0即表示这已是若干数据报片中的最后一个。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标志字段中的&lt;strong&gt;中间位DF&lt;/strong&gt;(Don’t Fragment)，意思是**“不能分片”**，只有当DF=0时才允许分片。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1.7 片偏移&lt;/strong&gt; &lt;strong&gt;占13位，指出较长的分钟再分片后，某片在原分组中的相对位置。&lt;/strong&gt; &lt;strong&gt;也就是说，相对于用户数据字段的起点，该片从何处开始。&lt;/strong&gt; 片偏移以8个字节为偏移单位。&lt;/p&gt;
&lt;p&gt;也就是说，&lt;strong&gt;每个分片的长度一定是8字节(64位)的整数倍。&lt;/strong&gt; 例子：一数据报的总长度为3820字节，其数据部分为3800字节长(使用固定首部)，需要分片为长度不超过1420字节的数据报片。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因固定首部长度为20字节，因此每个数据报片的数据部分长度不能超过1400字节&lt;/strong&gt;。于是分成3个数据报片，其数据部分的长度分别分为&lt;strong&gt;1400,1400和1000字节&lt;/strong&gt;。&lt;strong&gt;原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1.8 生存时间&lt;/strong&gt; &lt;strong&gt;占8位，常用的英文缩写是TTL(Time To Live)，表明数据报在网络中的寿命。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由&lt;strong&gt;发出数据报的源点设置这个字段&lt;/strong&gt;。 其目的是为了防止无法交付的数据报&lt;strong&gt;无限制地在因特网中兜圈子，因而白白浪费网络资源&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;随着技术的发展，&lt;strong&gt;TTL字段的功能改为“跳数限制”&lt;/strong&gt;。路由器在转发数据报之前就把TTL值减1。若TTL值减少到零，就丢弃这个数据报，不再转发。&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;现在TTL的单位不再是秒，而是跳数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;TTL的意义是指明数据报在因特网中&lt;strong&gt;至多可经过多少个路由器&lt;/strong&gt;。显然，数据报能在因特网中经过的&lt;strong&gt;路由器的最大数是255&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;若把&lt;strong&gt;TTL的初始值设置为1，就表示这个数据报只能在本局域网中传送&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1.9 协议&lt;/strong&gt; &lt;strong&gt;占8位，指出此数据报携带的数据是使用何种协议，一遍使目的主机的IP层知道应将数据部分上交给哪个处理过程。&lt;/strong&gt; 常用的一些协议和相应协议的字段值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1.10 首部检验和&lt;/strong&gt; &lt;strong&gt;占16位，只检验数据报的首部&lt;/strong&gt;，但不包括数据部分。&lt;/p&gt;
&lt;p&gt;这是因为数据报每经过一个路由器，路由器都要重新计算一下&lt;strong&gt;首部检验和&lt;/strong&gt;(一些字段，如生存时间、标志、片偏移等都可能发生变化)。 &lt;strong&gt;不检验数据部分可减少计算的工作量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了进一步减少计算检验和的工作量，IP首部的检验和不采用&lt;strong&gt;复杂的CRC检验码&lt;/strong&gt;而是采用以下算法： (1)在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置零。 (2)用反码算术运算把所有16位字相加后，将得到的和的反码写入检验和字段， (3)接收方收到数据报后，将首部的所有16位字再使用&lt;strong&gt;反码算术运算相加一次。将得到的和取反码&lt;/strong&gt;，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为0，于是就保留这个数据报，否则即认为出错，并将此数据报丢弃。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1.11 源地址&lt;/strong&gt; &lt;strong&gt;占32位。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1.12 目的地址&lt;/strong&gt; &lt;strong&gt;占32位。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ip数据报首部可变部分&#34;&gt;&lt;strong&gt;IP数据报首部——可变部分&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;IP首部的可变部分就是一个选项字段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2.1 可选字段(长度可变)&lt;/strong&gt; 选项字段用&lt;strong&gt;来支持排错、测量以及安全等措施，内容很丰富&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此字段的长度可变，从&lt;strong&gt;1~40个字节不等&lt;/strong&gt;，取决于所选择的项目。 某些选项项目只需要1个字节，它只包括1个字节的选项代码。但还有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2.2 填充&lt;/strong&gt; &lt;strong&gt;最后用全0的填充字段补齐成为4字节的整数倍。&lt;/strong&gt; 注：增加首部的可变部分是为了&lt;strong&gt;增加IP数据报的功能&lt;/strong&gt;，但这同时也使得IP数据报的&lt;strong&gt;首部长度成为可变的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。新的IP版本&lt;strong&gt;IPv6就把IP数据报的首部长度做成固定的&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22-tcp和udp的区别&#34;&gt;2.2 TCP和UDP的区别
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TCP：&lt;strong&gt;面向连接&lt;/strong&gt;（三次握手四次挥手），&lt;strong&gt;可靠&lt;/strong&gt;（握手、ACK和重传机制），&lt;strong&gt;面向字节流&lt;/strong&gt;（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），&lt;strong&gt;传输慢&lt;/strong&gt;， &lt;strong&gt;有流量控制阻塞控制&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;UDP：&lt;strong&gt;无连接的&lt;/strong&gt;，尽最大可能交付不可靠，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部） ，支持一对一、一对多、多对一和多对多的交互通信, &lt;strong&gt;传输快&lt;/strong&gt;，&lt;strong&gt;没有流量控制拥塞控制&lt;/strong&gt;，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解释一下报文和字节流的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字节流&lt;/strong&gt;：**发送次数和接收次数可以不相同。**比如向水池倒了20盆水，可以开水龙头一次性全放出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;报文&lt;/strong&gt;：&lt;strong&gt;发送次数和接收次数必须相同&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;两者的应用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP：&lt;strong&gt;效率要求相对低&lt;/strong&gt;，但对&lt;strong&gt;准确性要求相对高&lt;/strong&gt;的场景。
&lt;ul&gt;
&lt;li&gt;比如邮件，远程登录，文件传输等对&lt;strong&gt;准确性要求较高&lt;/strong&gt;的地方, 远程控制（SSH）,File Transfer Protocol（FTP）,邮件（SMTP、IMAP）等,点对点文件传出（微信等）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UDP：&lt;strong&gt;效率要求相对高&lt;/strong&gt;，&lt;strong&gt;传输快速&lt;/strong&gt;，对&lt;strong&gt;准确性要求相对低&lt;/strong&gt;的场景。
&lt;ul&gt;
&lt;li&gt;比如&lt;strong&gt;QQ聊天、在线视频、网络语音电话&lt;/strong&gt;等响应&lt;strong&gt;速度要求高&lt;/strong&gt;的场景，广播通信（广播、多播）。网络游戏, 音视频传输, DNS, Ping, 直播&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**第三类：模糊地带（TCP、UDP 都可以考虑），HTTP（目前以 TCP 为主），**文件传输？&lt;/p&gt;
&lt;h3 id=&#34;tcp报文段&#34;&gt;TCP报文段
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20190421142056148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psMTMwMTUyMTQ0NDI=,size_16,color_FFFFFF,t_70&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;序号 ：&lt;strong&gt;用于对字节流进行编号&lt;/strong&gt;，例如序号为 301，表示第一个字节的编号为301，&lt;strong&gt;如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401&lt;/strong&gt;，&lt;strong&gt;没有携带数据就是302&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;确认号ack ：&lt;strong&gt;期望收到的下一个报文段的序号&lt;/strong&gt;。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段 的序号为 701，B 发送给 A 的确认报文段中确认号就为 701，没有携带数据就是502。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据偏移&lt;/strong&gt; ：指的是&lt;strong&gt;数据部分距离报文段起始处的偏移量&lt;/strong&gt;，实际上&lt;strong&gt;指的是首部的长度&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;确认 ACK ：&lt;strong&gt;当 ACK=1 时确认号字段ack有效，否则无效&lt;/strong&gt;。TCP 规定，&lt;strong&gt;在连接建立后所有传送的报文段都必须把 ACK 置 1&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;同步 SYN ：&lt;strong&gt;在连接建立时用来同步序号&lt;/strong&gt;。当 &lt;strong&gt;SYN=1，ACK=0 时表示这是一个连接请求报文段&lt;/strong&gt;。若对方同意建立连接，则响应报文中 &lt;strong&gt;SYN=1，ACK=1&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;终止 FIN ：&lt;strong&gt;用来释放一个连接&lt;/strong&gt;，&lt;strong&gt;当 FIN=1 时，表示此报文段的发送方的数据已发送完毕&lt;/strong&gt;，并要求释放连接。&lt;/li&gt;
&lt;li&gt;窗口 ：&lt;strong&gt;窗口值作为接收方让发送方设置其发送窗口&lt;/strong&gt;的依据。之所以要有这个限制，是因为&lt;strong&gt;接收方的数据缓存空间&lt;/strong&gt;是有限的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MTU&lt;/code&gt;：一个网络包的最大长度，以太网中一般为 &lt;code&gt;1500&lt;/code&gt; 字节。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MSS&lt;/code&gt;：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如何查看 TCP 的连接状态？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP 的连接状态查看，在 Linux 可以通过 &lt;code&gt;netstat -napt&lt;/code&gt; 命令查看。&lt;/p&gt;
&lt;h2 id=&#34;24-三次握手和四次挥手&#34;&gt;2.4 三次握手和四次挥手
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://jiangren.work/2019/08/01/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://jiangren.work/2019/08/01/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;三次握手&#34;&gt;&lt;strong&gt;三次握手&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;所谓&lt;strong&gt;三次握手&lt;/strong&gt;是指&lt;strong&gt;建立&lt;/strong&gt;一个TCP连接时，&lt;strong&gt;需要客户端和服务器发送3个包&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.bmp.ovh/imgs/2019/07/8dabc100eb0549e0.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;名词解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SYN：Synchronize，&lt;strong&gt;同步标志位&lt;/strong&gt;，&lt;strong&gt;为1时表示序列号有效&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ACK：Acknowledgment，&lt;strong&gt;确认标志位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;seq：Synchronize Sequence Number，&lt;strong&gt;同步序列号&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ack：&lt;strong&gt;确认序列号&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;握手过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一次握手：客户端发送&lt;strong&gt;SYN标志为1&lt;/strong&gt;的包，以及&lt;strong&gt;同步序列号x&lt;/strong&gt;，并指明打算连接的&lt;strong&gt;服务器端口&lt;/strong&gt;。此时，&lt;strong&gt;connect进入阻塞状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端会随机初始化序号（&lt;code&gt;client_isn&lt;/code&gt;），将此序号置于 TCP 首部的「序号」字段中，同时把 &lt;code&gt;SYN&lt;/code&gt; 标志位置为 &lt;code&gt;1&lt;/code&gt; ，表示 &lt;code&gt;SYN&lt;/code&gt; 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 &lt;code&gt;SYN-SENT&lt;/code&gt; 状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二次握手：服务器收到后，发送&lt;strong&gt;SYN和ACK标志为1&lt;/strong&gt;的包，同时也发送一个自己的&lt;strong&gt;同步序列号y&lt;/strong&gt;，外加一个确认序列号&lt;strong&gt;ack=x+1&lt;/strong&gt;。此时accept进入阻塞状态。&lt;/p&gt;
&lt;p&gt;服务端收到客户端的 &lt;code&gt;SYN&lt;/code&gt; 报文后，首先服务端也随机初始化自己的序号（&lt;code&gt;server_isn&lt;/code&gt;），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 &lt;code&gt;client_isn + 1&lt;/code&gt;, 接着把 &lt;code&gt;SYN&lt;/code&gt; 和 &lt;code&gt;ACK&lt;/code&gt; 标志位置为 &lt;code&gt;1&lt;/code&gt;。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 &lt;code&gt;SYN-RCVD&lt;/code&gt; 状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三次握手：客户端收到后，再次发送&lt;strong&gt;ACK=1&lt;/strong&gt;，以及&lt;strong&gt;同步序列号seq(x+1)和确认序列号ack(y+1)&lt;/strong&gt;，与此同时，connect返回。当服务器收到ACK=1时，accept返回。&lt;/p&gt;
&lt;p&gt;客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 &lt;code&gt;ACK&lt;/code&gt; 标志位置为 &lt;code&gt;1&lt;/code&gt; ，其次「确认应答号」字段填入 &lt;code&gt;server_isn + 1&lt;/code&gt; ，最后把报文发送给服务端，&lt;strong&gt;这次报文可以携带客户到服务器的数据&lt;/strong&gt;，之后客户端处于 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器收到客户端的应答报文后，也进入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从上面的过程可以发现&lt;strong&gt;第三次握手是可以携带数据的，前两次握手是不可以携带数据的&lt;/strong&gt;，这也是面试常问的题。&lt;/p&gt;
&lt;h3 id=&#34;四次挥手&#34;&gt;&lt;strong&gt;四次挥手&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/69db7c9b-4035-4d2c-98a7-48038e4fa9db/Untitled.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Untitled&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端打算关闭连接，此时会发送一个 TCP 首部 &lt;code&gt;FIN&lt;/code&gt; 标志位被置为 &lt;code&gt;1&lt;/code&gt; 的报文，也即 &lt;code&gt;FIN&lt;/code&gt; 报文，之后客户端进入 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 状态。&lt;/li&gt;
&lt;li&gt;服务端收到该报文后，就向客户端发送 &lt;code&gt;ACK&lt;/code&gt; 应答报文，接着服务端进入 &lt;code&gt;CLOSED_WAIT&lt;/code&gt; 状态。&lt;/li&gt;
&lt;li&gt;客户端收到服务端的 &lt;code&gt;ACK&lt;/code&gt; 应答报文后，之后进入 &lt;code&gt;FIN_WAIT_2&lt;/code&gt; 状态。&lt;/li&gt;
&lt;li&gt;等待服务端处理完数据后，也向客户端发送 &lt;code&gt;FIN&lt;/code&gt; 报文，之后服务端进入 &lt;code&gt;LAST_ACK&lt;/code&gt; 状态。&lt;/li&gt;
&lt;li&gt;客户端收到服务端的 &lt;code&gt;FIN&lt;/code&gt; 报文后，回一个 &lt;code&gt;ACK&lt;/code&gt; 应答报文，之后进入 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态&lt;/li&gt;
&lt;li&gt;服务器收到了 &lt;code&gt;ACK&lt;/code&gt; 应答报文后，就进入了 &lt;code&gt;CLOSED&lt;/code&gt; 状态，至此服务端已经完成连接的关闭。&lt;/li&gt;
&lt;li&gt;客户端在经过 &lt;code&gt;2MSL&lt;/code&gt; 一段时间后，自动进入 &lt;code&gt;CLOSED&lt;/code&gt; 状态，至此客户端也完成连接的关闭&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;q1-为什么不能用两次握手连接&#34;&gt;Q&lt;strong&gt;1. 为什么不能用两次握手连接&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;三次握手才可以&lt;strong&gt;阻止重复历史连接的初始化&lt;/strong&gt;（主要原因）&lt;/li&gt;
&lt;li&gt;三次握手才可以&lt;strong&gt;同步双方的初始序列号&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;三次握手&lt;strong&gt;才可以避免资源浪费&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;原因一：避免历史连接&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那么此时服务端就会回一个 &lt;code&gt;SYN + ACK&lt;/code&gt; 报文给客户端；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端&lt;strong&gt;收到后可以根据自身的上下文，判断这是一个历史连接&lt;/strong&gt;（序列号过期或超时），那么客户端就会发送 &lt;code&gt;RST&lt;/code&gt; 报文给服务端，表示中止这一次连接。&lt;/p&gt;
&lt;p&gt;主要是因为&lt;strong&gt;在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两次握手的情况下，「被动发起方」在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据给，但是「主动发」起方此时还没有进入 ESTABLISHED 状态，假设这次是历史连接，主动发起方判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而「被动发起方」在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;原因二：同步双方初始序列号&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收方可以去除重复的数据；&lt;/li&gt;
&lt;li&gt;接收方可以根据数据包的序列号按序接收；&lt;/li&gt;
&lt;li&gt;可以标识发送出去的数据包中， 哪些是已经被对方收到的（&lt;strong&gt;通过 ACK 报文中的序列号知道&lt;/strong&gt;）；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;四次握手其实也能够可靠的同步双方的初始化序号，但由于&lt;strong&gt;第二步和第三步可以优化成一步&lt;/strong&gt;，所以就成了「三次握手」。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;原因三：避免资源浪费&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果只有「两次握手」，当客户端的 &lt;code&gt;SYN&lt;/code&gt; 请求连接在网络中阻塞，客户端没有接收到 &lt;code&gt;ACK&lt;/code&gt; 报文，就会重新发送 &lt;code&gt;SYN&lt;/code&gt; ，由于没有第三次握手，&lt;strong&gt;服务器不清楚客户端是否收到了自己发送的建立连接的 &lt;code&gt;ACK&lt;/code&gt; 确认信号&lt;/strong&gt;，&lt;strong&gt;所以每收到一个 &lt;code&gt;SYN&lt;/code&gt; 就只能先主动建立一个连接，这会造成什么情况呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果客户端的 &lt;code&gt;SYN&lt;/code&gt; 阻塞了，重复发送多次 &lt;code&gt;SYN&lt;/code&gt; 报文，那么服务器在收到请求后就会&lt;strong&gt;建立多个冗余的无效链接，造成不必要的资源浪费。这样就会造成死锁。也有可能打开两个连接或更多。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://img-blog.csdn.net/20180609003511513&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果握手只是两次，服务器端在没有确定客户端是否对自己做出了正确应答的情况下就建立了连接，此时客户端因为意外连接请求报文早就失效了，也不可能再理服务器端，但是&lt;strong&gt;服务器端会一直傻傻地等待客户端会发来点数据，造成了资源的浪费&lt;/strong&gt;。这真是服务器端自己自作多情啊。&lt;/p&gt;
&lt;p&gt;三次握手如果第三次失败了会怎么样：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;失败了服务端收到不确认包，会超时重发5次，若还是没有收到确认包，或者收到了数据包，则服务端直接发送reset重置包结束本次连接。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;q2-为什么连接是三次握手而关闭时是四次挥手&#34;&gt;Q&lt;strong&gt;2. 为什么连接是三次握手，而关闭时是四次挥手&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;为什么连接是三次握手：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了&lt;strong&gt;保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了&lt;strong&gt;保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;具体原因见Q1：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭时四次挥手：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关闭连接时，&lt;strong&gt;服务端需要回复两次。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;四次挥手之所以结束时需要多一次请求是因为：&lt;strong&gt;客户端单方面无数据发送认为可以结束了，但是服务端不一定没有数据发送。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以服务端要将&lt;strong&gt;确信信息&lt;/strong&gt;和&lt;strong&gt;自身发起断开&lt;/strong&gt;分作两步。&lt;/p&gt;
&lt;p&gt;再来回顾下四次挥手双方发 &lt;code&gt;FIN&lt;/code&gt; 包的过程，就能理解为什么需要四次了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关闭连接时，客户端向服务端发送 &lt;code&gt;FIN&lt;/code&gt; 时，仅仅&lt;strong&gt;表示客户端不再发送数据了但是还能接收数据&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;服务器收到客户端的 &lt;code&gt;FIN&lt;/code&gt; 报文时，先回一个 &lt;code&gt;ACK&lt;/code&gt; 应答报文，而&lt;strong&gt;服务端可能还有数据需要处理和发送，等服务端不再发送数据时&lt;/strong&gt;，才发送 &lt;code&gt;FIN&lt;/code&gt; 报文给客户端来表示同意现在关闭连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;q3-为什么time_wait状态需要经过2msl&#34;&gt;Q3. &lt;strong&gt;为什么TIME_WAIT状态需要经过2MSL？&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;2MSL是一次&lt;strong&gt;发送和回复的最大时间&lt;/strong&gt; (Maximum Segment Lifetime&lt;strong&gt;报文最大生存时间&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将&lt;strong&gt;重发第三次握手的FIN包&lt;/strong&gt;，主动关闭端接到重发的FIN包后可以再发一个ACK应答包，客户端最后一次发送ACK可能会丢失，如果此时冒然关闭，&lt;strong&gt;会导致服务器没收到ACK，然后一直不断地发Fin。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以需要等2MSL，&lt;strong&gt;如果超过这个时间，都还没有收到服务器的信息，说明已经完成，可以关闭&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MSL&lt;/code&gt; 是 Maximum Segment Lifetime，&lt;strong&gt;报文最大生存时间&lt;/strong&gt;，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。&lt;/p&gt;
&lt;p&gt;因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 &lt;code&gt;TTL&lt;/code&gt; 字段，是 IP 数据报可以经过的最大路由数，&lt;strong&gt;每经过一个处理他的路由器此值就减 1&lt;/strong&gt;，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。&lt;/p&gt;
&lt;p&gt;MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 &lt;strong&gt;MSL 应该要大于等于 TTL 消耗为 0 的时间&lt;/strong&gt;，以确保报文已被自然消亡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TTL 的值一般是 64，Linux 将 MSL 设置为 60秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;q4-为什么每次建立-tcp-连接时初始化的序列号都要求不一样呢&#34;&gt;Q4. 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？
&lt;/h3&gt;&lt;p&gt;主要原因有两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了&lt;strong&gt;防止历史报文被下一个相同四元组的连接接收（主要方面）&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;为了&lt;strong&gt;安全性&lt;/strong&gt;，防止&lt;strong&gt;黑客伪造的相同序列号的 TCP 报文&lt;/strong&gt;被对方接收；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;q5-初始序列号-isn-是如何随机产生的&#34;&gt;Q5. 初始序列号 ISN 是如何随机产生的？
&lt;/h3&gt;&lt;p&gt;起始 &lt;code&gt;ISN&lt;/code&gt; 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。&lt;/p&gt;
&lt;p&gt;RFC793 提到初始化序列号 ISN 随机生成算法：ISN = M + F(localhost, localport, remotehost, remoteport)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;M&lt;/code&gt; 是一个计时器，这个计时器每隔 4 微秒加 1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F&lt;/code&gt; 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，随机数是会&lt;strong&gt;基于时钟计时器递增的&lt;/strong&gt;，基本不可能会随机成一样的初始化序列号。&lt;/p&gt;
&lt;h3 id=&#34;q6-既然-ip-层会分片为什么-tcp-层还需要-mss-呢&#34;&gt;Q6. 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;MTU&lt;/code&gt;&lt;/strong&gt;：一个网络包的最大长度，以太网中一般为 &lt;code&gt;1500&lt;/code&gt; 字节；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;MSS&lt;/code&gt;&lt;/strong&gt;：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在 TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？&lt;/p&gt;
&lt;p&gt;当 IP 层有一个超过 &lt;code&gt;MTU&lt;/code&gt; 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，再交给上一层 TCP 传输层。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这看起来井然有序，但这存在隐患的，&lt;strong&gt;那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，为了达到最佳的传输效能 TCP 协议在&lt;strong&gt;建立连接的时候通常要协商双方的 MSS 值&lt;/strong&gt;，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。&lt;/p&gt;
&lt;h3 id=&#34;q7-第一次第二次第三次握手丢失了会发生什么&#34;&gt;Q7. 第一次，第二次，第三次握手丢失了，会发生什么？
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;第一次握手丢失了，会发生什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 &lt;code&gt;SYN_SENT&lt;/code&gt; 状态。在这之后，&lt;strong&gt;如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，&lt;strong&gt;这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核&lt;/strong&gt;，比较麻烦。当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 Linux 里，客户端的 SYN 报文最大重传次数由 &lt;code&gt;tcp_syn_retries&lt;/code&gt;内核参数控制&lt;/strong&gt;，这个参数是可以自定义的，默认值一般是 5。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，每次超时的时间是上一次的 2 倍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第二次握手丢失了，会发生什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;当第二次握手丢失了，客户端和服务端都会重传&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 &lt;code&gt;tcp_syn_retries&lt;/code&gt;内核参数决定；&lt;/li&gt;
&lt;li&gt;服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 &lt;code&gt;tcp_synack_retries&lt;/code&gt; 内核参数决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果第二次握手丢失了，服务端就收不到第三次握手，于是&lt;strong&gt;服务端这边会触发超时重传机制，重传 SYN-ACK 报文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 Linux 下，SYN-ACK 报文的最大重传次数由 &lt;code&gt;tcp_synack_retries&lt;/code&gt;内核参数决定，默认值是 5。&lt;/p&gt;
&lt;p&gt;当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 &lt;code&gt;SYN_RCVD&lt;/code&gt; 状态。&lt;/p&gt;
&lt;p&gt;第二次握手的 &lt;code&gt;SYN-ACK&lt;/code&gt; 报文其实有两个目的 ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第二次握手里的 ACK， 是对第一次握手的确认报文；&lt;/li&gt;
&lt;li&gt;第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，如果第二次握手丢了，就会发送比较有意思的事情，具体会怎么样呢？&lt;/p&gt;
&lt;p&gt;因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文。&lt;/p&gt;
&lt;p&gt;如果客户端迟迟没有收到第二次握手，&lt;strong&gt;那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第三次握手丢失了，会发生什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;当第三次握手丢失了，服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文&lt;/strong&gt;，直到收到第三次握手，或者达到最大重传次数。&lt;/p&gt;
&lt;p&gt;客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 &lt;code&gt;ESTABLISH&lt;/code&gt; 状态。&lt;/p&gt;
&lt;p&gt;因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，&lt;strong&gt;所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文&lt;/strong&gt;，直到收到第三次握手，或者达到最大重传次数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意，&lt;strong&gt;ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;q8-第一次第二次第三次第四次挥手丢失了都会发生什么&#34;&gt;Q8. 第一次，第二次，第三次，第四次挥手丢失了，都会发生什么？
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;第一次挥手丢失了，会发生什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 &lt;code&gt;tcp_orphan_retries&lt;/code&gt; 参数控制。当客户端重传 FIN 报文的次数超过 &lt;code&gt;tcp_orphan_retries&lt;/code&gt; 后，就不再发送 FIN 报文，直接进入到 &lt;code&gt;close&lt;/code&gt; 状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 &lt;code&gt;FIN_WAIT_1&lt;/code&gt; 状态。正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 &lt;code&gt;FIN_WAIT2&lt;/code&gt;状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第二次挥手丢失了，会发生什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以如果服务端的第二次挥手丢失了，&lt;strong&gt;客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 &lt;code&gt;CLOSE_WAIT&lt;/code&gt; 状态。在前面我们也提了，ACK 报文是不会重传的。&lt;/p&gt;
&lt;p&gt;这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 &lt;code&gt;FIN_WAIT2&lt;/code&gt; 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。&lt;/p&gt;
&lt;p&gt;对于 close 函数关闭的连接，由于&lt;strong&gt;无法再发送和接收数据&lt;/strong&gt;，&lt;strong&gt;所以&lt;code&gt;FIN_WAIT2&lt;/code&gt; 状态不可以持续太久，而 &lt;code&gt;tcp_fin_timeout&lt;/code&gt; 控制了这个状态下连接的持续时长，默认值是 60 秒。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是注意，如果主动关闭方&lt;strong&gt;使用 shutdown 函数关闭连接且指定只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 &lt;code&gt;FIN_WAIT2&lt;/code&gt; 状态（&lt;code&gt;tcp_fin_timeout&lt;/code&gt; 无法控制 shutdown 关闭的连接）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第三次挥手丢失了，会发生什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文&lt;/strong&gt;，重发次数仍然由 &lt;strong&gt;&lt;code&gt;tcp_orphan_retries&lt;/code&gt;&lt;/strong&gt; 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。&lt;/p&gt;
&lt;p&gt;当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 &lt;code&gt;CLOSE_WAIT&lt;/code&gt; 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。&lt;/p&gt;
&lt;p&gt;此时，内核是没有权利替代进程关闭连接，必须由&lt;strong&gt;进程主动调用 close 函数来触发服务端发送&lt;/strong&gt; FIN 报文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第四次挥手丢失了，会发生什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 &lt;code&gt;tcp_orphan_retries&lt;/code&gt; 参数控制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 &lt;code&gt;TIME_WAIT&lt;/code&gt; 状态。&lt;/p&gt;
&lt;p&gt;在 Linux 系统，TIME_WAIT 状态会持续 2MSL 后才会进入关闭状态。&lt;/p&gt;
&lt;p&gt;然后，服务端（被动关闭方）&lt;strong&gt;没有收到 ACK 报文前，还是处于 LAST_ACK&lt;/strong&gt; 状态。&lt;/p&gt;
&lt;h3 id=&#34;q9--为什么需要-time_wait-状态&#34;&gt;Q9.  为什么需要 TIME_WAIT 状态？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;避免连接混淆或者连接冲突，防止历史连接中的数据，被后面相同四元组的连接错误的接收&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保证「被动关闭连接」的一方，能被正确的关闭，确保最后的数据包被接收，或处理延迟包&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;TIME_WAIT 过多有什么危害？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;过多的 TIME-WAIT 状态主要的危害有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一是内存资源占用&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二是对端口资源的占用&lt;/strong&gt;，一个 TCP 连接至少消耗「发起连接方」的一个本地端口；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;25-tcp协议如何保证可靠性&#34;&gt;2.5 TCP协议如何保证可靠性
&lt;/h2&gt;&lt;p&gt;TCP 是通过&lt;strong&gt;序列号、确认应答、重发控制、连接管理以及窗口控制&lt;/strong&gt;等机制实现可靠性传输的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）&lt;strong&gt;采用&lt;/strong&gt;三次握手四次挥手&lt;/strong&gt;保证建立的&lt;strong&gt;传输信道是可靠的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）&lt;strong&gt;采用了&lt;/strong&gt;ARQ自动(超时)重传请求&lt;/strong&gt;协议&lt;strong&gt;数据传输的可靠性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）&lt;strong&gt;采用&lt;/strong&gt;滑动窗口&lt;/strong&gt;协议进行&lt;strong&gt;流量控制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）&lt;strong&gt;使用&lt;/strong&gt;慢开始&lt;/strong&gt;、&lt;strong&gt;拥塞避免&lt;/strong&gt;、&lt;strong&gt;快重传&lt;/strong&gt;和&lt;strong&gt;快恢复&lt;/strong&gt;来进行&lt;strong&gt;拥塞控制&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）校验和CRC计算方式&lt;/strong&gt;：在数据传输的过程中，将发送的数据段都当做一个&lt;strong&gt;16位的整数&lt;/strong&gt;。将这些&lt;strong&gt;整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;发送方：在发送数据之前计算检验和，并进行校验和的填充。&lt;/p&gt;
&lt;p&gt;接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（6）确认应答与序列号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;序列号：TCP传输时将每个字节的数据都进行了编号。&lt;/p&gt;
&lt;p&gt;确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。&lt;/p&gt;
&lt;h3 id=&#34;自动超时重传机制&#34;&gt;&lt;strong&gt;自动超时重传机制&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;简单理解就是&lt;strong&gt;发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于TCP传输时&lt;strong&gt;保证能够在任何环境下都有一个高性能的通信&lt;/strong&gt;，因此这个&lt;strong&gt;最大超时时间（也就是等待的时间）是动态计算的&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Linux中（BSD Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是&lt;strong&gt;500ms的整数倍&lt;/strong&gt;。重发一次后，仍未响应，那么等待2500ms的时间后，再次重传。等待4500ms的时间继续重传。&lt;strong&gt;以一个指数的形式增长&lt;/strong&gt;。&lt;strong&gt;累计到一定的重传次数&lt;/strong&gt;，TCP就认为&lt;strong&gt;网络或者对端出现异常，强制关闭连接。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体步骤如下：&lt;/p&gt;
&lt;p&gt;（1）&lt;strong&gt;为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;（2）并为每个&lt;strong&gt;已发送的数据包启动一个超时定时器&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;（3）如在&lt;strong&gt;定时器超时之前收到了对方发来的应答信息&lt;/strong&gt;（可能是对本包的应答，也可以是对本包后续包的应答），则&lt;strong&gt;释放该数据包占用的缓冲区;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（4）否则，&lt;strong&gt;重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（5）接收方收到数据包后，&lt;strong&gt;先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到&lt;/strong&gt;，&lt;strong&gt;如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果接收方收到二次重发的数据后，便进行ACK应答。&lt;/p&gt;
&lt;p&gt;如果接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说&lt;strong&gt;序列号还有去除重复数据的作用&lt;/strong&gt;），那么&lt;strong&gt;直接丢弃，仍旧发送ACK应答&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;26-tcp协议如何进行流量控制&#34;&gt;2.6 TCP协议如何进行流量控制？
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;控制流量的前提当然需要保证正确率可靠性，因此首先要引入ARQ(自动重传请求（Automatic Repeat-reQuest，&lt;em&gt;ARQ&lt;/em&gt;）协议。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP采用&lt;strong&gt;大小可变的滑动窗口&lt;/strong&gt;进行流量控制，&lt;strong&gt;窗口大小的单位是字节&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数据接收端将&lt;strong&gt;自己可以接受的缓冲区大小放入TCP首部中“窗口大小”字段&lt;/strong&gt;，通过ACK来通知数据传输。（&lt;strong&gt;在TCP的首部，有一个16位窗口字段，此字段就是用来存放窗口大小信息的。）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无差错时，A向B发送&lt;strong&gt;分组&lt;/strong&gt;M1，B收到M1后向A回复，A收到回复后，发送下一个M2…..&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214122158.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;如果出现差错，B没有收到信息，自然不会回复，&lt;strong&gt;A等待超时后&lt;/strong&gt;，&lt;strong&gt;自动重传&lt;/strong&gt;一个信息M，这就是所谓的ARQ。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但停止等待ARQ协议信道利用率太低。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以需要使用&lt;strong&gt;连续ARQ协议来进行改善&lt;/strong&gt;。这个协议会&lt;strong&gt;连续发送一组数据包&lt;/strong&gt;，然后&lt;strong&gt;再等待这些数据包的ACK&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214123227.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连续ARQ协议&lt;/strong&gt;通常是&lt;strong&gt;结合滑动窗口协议&lt;/strong&gt;来使用的，&lt;strong&gt;发送方需要维持一个发送窗口&lt;/strong&gt;，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214123327.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;位于&lt;strong&gt;发送窗口内的5个分组&lt;/strong&gt;都可以连续发送出去，而不需要等待对方的确认，这样就提高了&lt;strong&gt;信道利用率&lt;/strong&gt;。、&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接收方一般都是采用累积确认的方式&lt;/strong&gt;。收到几个分组后，对按序到达的&lt;strong&gt;最后一个分组发送确认&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;滑动窗口需掌握的知识点：&lt;/p&gt;
&lt;p&gt;A、数据&lt;strong&gt;接收端将自己可以接受的缓冲区大小放入TCP首部中“窗口大小”字段&lt;/strong&gt;，&lt;strong&gt;通过ACK来通知数据传输端。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B、&lt;strong&gt;窗口大小字段越大，说明网络的吞吐率越高。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C、窗口大小指的是&lt;strong&gt;无需等待确认应答而可以继续发送数据的最大值&lt;/strong&gt;，即就是说&lt;strong&gt;不需要数据接收端的应答，可以一次连续的发送数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;D、&lt;strong&gt;操作系统内核为了维护滑动窗口，需要开辟发送缓冲区&lt;/strong&gt;，&lt;strong&gt;来记录当前还有哪些数据没有应答&lt;/strong&gt;，&lt;strong&gt;只有确认应答过的数据，才能从缓冲区删除&lt;/strong&gt;。 &lt;strong&gt;(PS：发送缓冲区如果太大，会有空间开销）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;E、数据接收端一旦&lt;strong&gt;发现自己的缓冲区快满了&lt;/strong&gt;，&lt;strong&gt;就会将窗口大小设置成一个更小的值通知给数据传输端，数据传输端收到这个值后，就会减慢自己的发送速度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;F、如果&lt;strong&gt;数据接收端发现自己的缓冲区满了&lt;/strong&gt;，&lt;strong&gt;就会将窗口大小设置为0&lt;/strong&gt;，此时数据传输端不再传输数据，但是&lt;strong&gt;需要定期发送一个窗口探测数据段&lt;/strong&gt;，将&lt;strong&gt;数据接收端把窗口大小告诉数据传输端&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;q1-tcp-是如何解决窗口关闭时潜在的死锁现象呢&#34;&gt;Q1. TCP 是如何解决窗口关闭时，潜在的死锁现象呢？
&lt;/h3&gt;&lt;p&gt;为了解决这个问题，&lt;strong&gt;TCP 为每个连接设有一个持续定时器&lt;/strong&gt;，&lt;strong&gt;只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果&lt;strong&gt;持续计时器超时，就会发送窗口探测 ( Window probe ) 报文&lt;/strong&gt;，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;窗口探测的次数一般为 3 次，每次大约 30-60 秒&lt;/strong&gt;（不同的实现可能会不一样）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 &lt;code&gt;RST&lt;/code&gt; 报文来中断连接。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;27-tcp协议如何进行拥塞控制&#34;&gt;2.7 TCP协议如何进行拥塞控制？
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;下载时我们的速度一般都是由慢变快，原因就是拥塞控制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络拥塞是指在&lt;strong&gt;分组交换网络中传送分组的数目太多&lt;/strong&gt;时，由于&lt;strong&gt;存储转发节点的资源有限&lt;/strong&gt;而造成&lt;strong&gt;网络传输性能下降&lt;/strong&gt;的情况。&lt;/p&gt;
&lt;p&gt;常见的拥塞控制有：&lt;strong&gt;慢开始，拥塞避免，快重传，快恢复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;慢开始：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小&lt;/strong&gt;, 一次RTT(&lt;em&gt;RTT&lt;/em&gt;(Round-Trip Time)：往返时延)后，也就是&lt;strong&gt;收到一次ACK后拥塞窗口就翻倍&lt;/strong&gt;，也就是指数型增长。&lt;/p&gt;
&lt;p&gt;**拥塞避免：**拥塞避免算法让拥塞窗口缓慢增长，&lt;strong&gt;即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍&lt;/strong&gt;。这样拥塞窗口按线性规律缓慢增长。&lt;/p&gt;
&lt;p&gt;发送方维持一个叫做&lt;strong&gt;拥塞窗口cwnd（congestion window）的状态变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当cwnd到达ssthresh（慢启动阈值）时&lt;/strong&gt;，改用&lt;strong&gt;拥塞避免&lt;/strong&gt;算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拥塞窗口 cwnd&lt;/strong&gt;是&lt;strong&gt;发送方维护的一个的状态变量&lt;/strong&gt;，它会根据&lt;strong&gt;网络的拥塞程度动态变化的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们在前面提到过&lt;strong&gt;发送窗口 &lt;code&gt;swnd&lt;/code&gt; 和接收窗口 &lt;code&gt;rwnd&lt;/code&gt; 是约等于的关系&lt;/strong&gt;，那么由于&lt;strong&gt;加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)&lt;/strong&gt;，也就是&lt;strong&gt;拥塞窗口和接收窗口中的最小值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拥塞窗口 &lt;code&gt;cwnd&lt;/code&gt; 变化的规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只要网络中&lt;strong&gt;没有出现拥塞，&lt;code&gt;cwnd&lt;/code&gt; 就会增大；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;但网络中&lt;strong&gt;出现了拥塞，&lt;code&gt;cwnd&lt;/code&gt; 就减少；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;快重传：&lt;strong&gt;我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在&lt;/strong&gt;收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;快重传规定：&lt;strong&gt;发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段&lt;/strong&gt;，&lt;strong&gt;而不必继续等待设置的重传计时器时间到期&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214125708.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;**快恢复：**主要是配合快重传。&lt;strong&gt;当发送方连续收到三个重复确认时，就执行“乘法减小”算法&lt;/strong&gt;，&lt;strong&gt;把ssthresh门限减半&lt;/strong&gt;（&lt;strong&gt;为了预防网络发生拥塞&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;但&lt;strong&gt;接下来并不执行慢开始算法&lt;/strong&gt;，因&lt;strong&gt;为如果网络出现拥塞的话就不会收到好几个重复的确认&lt;/strong&gt;，&lt;strong&gt;收到三个重复确认说明网络状况还可以&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214130136.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;快速重传机制&lt;strong&gt;只解决了一个问题，就是超时时间&lt;/strong&gt;的问题，但是它依然面临着另外一个问题。&lt;/p&gt;
&lt;p&gt;就是&lt;strong&gt;重传的时候，是重传之前的一个，还是重传所有的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。&lt;/p&gt;
&lt;p&gt;根据 TCP 不同的实现，以上两种情况都是有可能的。可见，这是一把双刃剑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了解决不知道该重传哪些 TCP 报文，于是就有 &lt;code&gt;SACK&lt;/code&gt; 方法。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;sack-方法&#34;&gt;SACK 方法
&lt;/h3&gt;&lt;p&gt;一种实现重传机制的方式叫：&lt;code&gt;SACK&lt;/code&gt;（ Selective Acknowledgment 选择性确认）。&lt;/p&gt;
&lt;p&gt;这种方式需要&lt;strong&gt;在 TCP 头部「选项」字段里加一个 &lt;code&gt;SACK&lt;/code&gt; 的东西&lt;/strong&gt;，它可以&lt;strong&gt;将缓存的地图发送给发送方&lt;/strong&gt;，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以&lt;strong&gt;只重传丢失的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如某图例子(发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，&lt;strong&gt;通过 &lt;code&gt;SACK&lt;/code&gt; 信息发现只有 &lt;code&gt;200~299&lt;/code&gt; 这段数据丢失&lt;/strong&gt;，则重发时，就只选择了这个 TCP 段进行重复。&lt;/p&gt;
&lt;h2 id=&#34;28-socket编程tcp&#34;&gt;2.8 Socket编程TCP
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;服务端和客户端初始化 &lt;code&gt;socket&lt;/code&gt;&lt;/strong&gt;，得到文件描述符；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务端调用 &lt;code&gt;bind&lt;/code&gt;()，将文件描述符绑定在 IP 地址和端口;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;服务端&lt;strong&gt;调用 &lt;code&gt;listen&lt;/code&gt;，进行监听&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务端调用 &lt;code&gt;accept&lt;/code&gt;，等待客户端连接；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端调用 &lt;code&gt;connect&lt;/code&gt;，向服务器端的地址和端口发起连接请求；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;服务端 &lt;code&gt;accept&lt;/code&gt; &lt;strong&gt;返回用于传输的 &lt;code&gt;socket&lt;/code&gt; 的文件描述符；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;客户端&lt;strong&gt;调用 &lt;code&gt;write&lt;/code&gt; 写入数据；服务端调用 &lt;code&gt;read&lt;/code&gt; 读取数据&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;客户端断开连接时，会调用 &lt;code&gt;close&lt;/code&gt;，那么&lt;strong&gt;服务端 &lt;code&gt;read&lt;/code&gt; 读取数据的时候，就会读取到了 &lt;code&gt;EOF&lt;/code&gt;&lt;/strong&gt;，待处理完数据后，服务端调用 &lt;code&gt;close&lt;/code&gt;，表示连接关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux内核中会维护两个队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;半连接队列（SYN 队列）：接收到&lt;strong&gt;一个 SYN 建立连接请求，处于 SYN_RCVD 状态&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;全连接队列（Accpet 队列）：&lt;strong&gt;已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的描述过程，我们可以得知&lt;strong&gt;客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端调用 close 了，连接是断开的流程是什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们看看客户端主动调用了 &lt;code&gt;close&lt;/code&gt;，会发生什么？&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzM3LmpwZw?x-oss-process=image/format,png&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;客户端调用 close 过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端调用 &lt;code&gt;close&lt;/code&gt;，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；&lt;/li&gt;
&lt;li&gt;服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包&lt;strong&gt;插入一个文件结束符 &lt;code&gt;EOF&lt;/code&gt; 到接收缓冲区中，应用程序可以通过 &lt;code&gt;read&lt;/code&gt; 调用来感知这个 FIN 包&lt;/strong&gt;。
&lt;ul&gt;
&lt;li&gt;这个 &lt;code&gt;EOF&lt;/code&gt; 会被&lt;strong&gt;放在已排队等候的其他已接收的数据之后&lt;/strong&gt;，这就意味着&lt;strong&gt;服务端需要处理这种异常情况&lt;/strong&gt;，&lt;strong&gt;因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接着，当处理完数据后，自然就会读到 &lt;code&gt;EOF&lt;/code&gt;，于是也调用 &lt;code&gt;close&lt;/code&gt; 关闭它的套接字，这会使得服务端发出一个 FIN 包，之后处于 LAST_ACK 状态；&lt;/li&gt;
&lt;li&gt;客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；&lt;/li&gt;
&lt;li&gt;服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；&lt;/li&gt;
&lt;li&gt;客户端经过 &lt;code&gt;2MSL&lt;/code&gt; 时间之后，也进入 CLOSE 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;29-增大-tcp-半连接队列和全连接队列的方式&#34;&gt;2.9 增大 TCP 半连接队列和全连接队列的方式
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;增大 TCP 半连接队列的方式是增大 &lt;strong&gt;/proc/sys/net/ipv4/tcp_max_syn_backlog；&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;增大 TCP 全连接队列的方式是增大 &lt;strong&gt;listen() 函数中的 backlog；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux系统中，则使用两个队列syn queue, accept queue分别存储状态为SYN_REVD和ESTABLISHED的连接，并且在linux2.2及以后，backlog表示accept queue的大小，而syn queue大小由 &lt;code&gt;/proc/sys/net/ipv4/tcp_max_syn_backlog&lt;/code&gt;配置。&lt;/p&gt;
&lt;h2 id=&#34;内核参数somaxconn&#34;&gt;&lt;strong&gt;内核参数somaxconn&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;全称：socket max connections 位置：&lt;code&gt;/proc/sys/net/core/somaxconn&lt;/code&gt; 这是系统层面对于backlog的控制，实际上accept queue的大小 = min(somaxconn, backlog)。&lt;/p&gt;
&lt;p&gt;因此在listen这个系统调用层面，backlog最终还是受限于somaxconn。&lt;/p&gt;
&lt;h2 id=&#34;查看队列&#34;&gt;&lt;strong&gt;查看队列&lt;/strong&gt;
&lt;/h2&gt;&lt;p&gt;`ss -l&lt;/p&gt;
&lt;p&gt;Netid   State    Recv-Q   Send-Q                                      Local Address:Port                     Peer Address:Port
tcp     LISTEN   0        128                                                  [::]:ssh                              [::]:*`&lt;/p&gt;
&lt;p&gt;在LISTEN状态下 Recv-Q 表示当前accept queue中的已连接数。Send-Q 表示总大小&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;210-如何优化-tcp&#34;&gt;2.10 如何优化 TCP
&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;你可以根据网络的稳定性和目标服务器的繁忙程度修改 **SYN 的重传次数**，**调整客户端的三次握手时间上限**。TCP 三次握手的性能提升；TCP 四次挥手的性能提升；TCP 数据传输的性能提升；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;q1-三次握手优化&#34;&gt;Q1: &lt;strong&gt;三次握手优化&lt;/strong&gt;
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;客户端的优化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当客户端发起 SYN 包时，可以通过 &lt;code&gt;tcp_syn_retries&lt;/code&gt; 控制其重传的次数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务端的优化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以通过 &lt;code&gt;netstat -s&lt;/code&gt; 观察半连接队列溢出的情况。&lt;/p&gt;
&lt;p&gt;如果 SYN 半连接队列溢出情况比较严重，可以通过 &lt;code&gt;tcp_max_syn_backlog、somaxconn、backlog&lt;/code&gt; 参数来调整 SYN 半连接队列的大小。&lt;/p&gt;
&lt;p&gt;服务端回复 SYN+ACK 的重传次数由 &lt;code&gt;tcp_synack_retries&lt;/code&gt; 参数控制。&lt;/p&gt;
&lt;p&gt;如果遭受 SYN 攻击，应把 &lt;code&gt;tcp_syncookies&lt;/code&gt; 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接成功建立。&lt;/p&gt;
&lt;p&gt;服务端收到客户端返回的 ACK，会把连接移入 accpet 队列，等待进行调用 accpet() 函数取出连接。&lt;/p&gt;
&lt;p&gt;可以通过 &lt;code&gt;ss -lnt&lt;/code&gt; 查看服务端进程的 accept 队列长度&lt;/p&gt;
&lt;p&gt;如果 &lt;strong&gt;accept 队列溢出，系统默认丢弃 ACK&lt;/strong&gt;，如果可以把 &lt;code&gt;tcp_abort_on_overflow&lt;/code&gt; 设置为 1 ，表示用 RST 通知客户端连接建立失败。&lt;/p&gt;
&lt;p&gt;如果 accpet 队列溢出严重，可以通过 listen 函数的 &lt;code&gt;backlog&lt;/code&gt; 参数和 &lt;code&gt;somaxconn&lt;/code&gt; 系统参数提高队列大小，accept 队列长度取决于 min(backlog, somaxconn)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;绕过三次握手&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP Fast Open 功能可以绕过三次握手，使得 HTTP 请求减少了 1 个 RTT 的时间，Linux 下可以通过 &lt;code&gt;tcp_fastopen&lt;/code&gt; 开启该功能，同时必须保证服务端和客户端同时支持。&lt;/p&gt;
&lt;h3 id=&#34;q2-tcp-四次挥手的性能提升&#34;&gt;Q2: &lt;strong&gt;TCP 四次挥手的性能提升&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;针对 TCP 四次挥手的优化，我们需要根据主动方和被动方四次挥手状态变化来调整系统 TCP 内核参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/39.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;四次挥手的优化策略&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主动方的优化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;主动发起 FIN 报文断开连接的一方，如果迟迟没收到对方的 ACK 回复，则会重传 FIN 报文，重传的次数由 &lt;code&gt;tcp_orphan_retries&lt;/code&gt; 参数决定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当主动方收到 ACK 报文后，连接就进入 FIN_WAIT2 状态，根据关闭的方式不同，优化的方式也不同：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果这是 close 函数关闭的连接，那么它就是孤儿连接。如果 &lt;code&gt;tcp_fin_timeout&lt;/code&gt; 秒内没有收到对方的 FIN 报文，连接就直接关闭。同时，为了应对孤儿连接占用太多的资源，&lt;code&gt;tcp_max_orphans&lt;/code&gt; 定义了最大孤儿连接的数量，超过时连接就会直接释放。&lt;/li&gt;
&lt;li&gt;反之是 shutdown 函数关闭的连接，则不受此参数限制；&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当主动方接收到 FIN 报文，并返回 ACK 后，主动方的连接进入 TIME_WAIT 状态。这一状态会持续 1 分钟，为了防止 TIME_WAIT 状态占用太多的资源，&lt;code&gt;tcp_max_tw_buckets&lt;/code&gt; 定义了最大数量，超过时连接也会直接释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当 TIME_WAIT 状态过多时，还可以通过设置 &lt;code&gt;tcp_tw_reuse&lt;/code&gt; 和 &lt;code&gt;tcp_timestamps&lt;/code&gt; 为 1 ，将 TIME_WAIT 状态的端口复用于作为客户端的新连接，注意该参数只适用于客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;被动方的优化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;被动关闭的连接方应对非常简单，它在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。&lt;/p&gt;
&lt;p&gt;当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，会在 &lt;code&gt;tcp_orphan_retries&lt;/code&gt; 参数的控制下重发 FIN 报文。&lt;/p&gt;
&lt;h3 id=&#34;q3-tcp-数据传输的性能提升&#34;&gt;Q3: TCP 数据传输的性能提升
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%82%E6%95%B0/49.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;211-如何解决粘包&#34;&gt;2.11 如何解决粘包？
&lt;/h2&gt;&lt;p&gt;（1）&lt;strong&gt;发送方引起的粘包是由TCP协议本身造成的&lt;/strong&gt;，TCP为提高传输效率，&lt;strong&gt;发送方往往要收集到足够多的数据后才发送一包数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;若连续几次发送的数据都很少，&lt;strong&gt;通常TCP会根据优化算法把这些数据合成一包后一次发送出去&lt;/strong&gt;，这样接收方就收到了粘包数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UDP不存在粘包问题, 是由于UDP发送的时候, 没有经过Negal算法优化, 不会将多个小包合并一次发送出去&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外，&lt;strong&gt;在UDP协议的接收端,采用了链式结构来记录每一个到达的UDP包，这样接收端应用程序一次recv只能从socket接收缓冲区中读出一个数据包&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也就是说,发送端send了几次，接收端必须recv几次(无论recv时指定了多大的缓冲区)&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走&lt;/strong&gt;，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而&lt;strong&gt;用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;粘包的问题出现是&lt;strong&gt;因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一般有三种方式分包的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定长度的消息；&lt;/li&gt;
&lt;li&gt;特殊字符作为边界；&lt;/li&gt;
&lt;li&gt;自定义消息结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;固定长度的消息固定长度的消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是这种方式灵活性不高，实际中很少用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;特殊字符作为边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。&lt;/p&gt;
&lt;p&gt;HTTP 是一个非常好的例子。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/a49a6bb8cd38ae1738d9c00aec68b444.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一点要注意，这个作为边界点的特殊字符，如果&lt;strong&gt;刚好消息内容里有这个特殊字符，我们要对这个字符转义&lt;/strong&gt;，&lt;strong&gt;避免被接收方当作消息的边界点而解析到无效的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;自定义消息结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以&lt;strong&gt;自定义一个消息结构，由包头和数据组成&lt;/strong&gt;，其中包头包是固定大小的，而且&lt;strong&gt;包头里有一个字段来说明紧随其后的数据有多大&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如这个消息结构体，首先 &lt;strong&gt;4 个字节大小的变量来表示数据长度&lt;/strong&gt;，真正的数据则在后面。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;u_int32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message_length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;212-syn-报文什么时候情况下会被丢弃&#34;&gt;2.12 SYN 报文什么时候情况下会被丢弃？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;开启 tcp_tw_recycle 参数，并且在 NAT 环境下，造成 SYN 报文被丢弃，由于 NAT 环境中的客户端可能有不同的时间戳时钟和值，&lt;strong&gt;tcp_tw_recycle&lt;/strong&gt; 在这种环境中可能会导致合法的 SYN 报文被误丢弃。因此，如果你的服务器有 NAT 后面的客户端连接，通常建议不要启用 &lt;strong&gt;tcp_tw_recycle&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TCP 两个队列满了（半连接队列和全连接队列）&lt;/strong&gt;，造成 SYN 报文被丢弃&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/network/3_tcp/syn_drop.html#%E5%9D%91%E7%88%B9%E7%9A%84-tcp-tw-recycle&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;4.8 SYN 报文什么时候情况下会被丢弃？ | 小林coding (xiaolincoding.com)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Linux 操作系统下，&lt;strong&gt;TIME_WAIT 状态的持续时间是 60 秒&lt;/strong&gt;，这意味着这 60 秒内，客户端一直会占用着这个端口。要知道，端口资源也是有限的，一般可以开启的端口为 32768~61000 ，也可以通过如下参数设置指定范围：&lt;/p&gt;
&lt;p&gt;不过，Linux 操作系统提供了两个可以系统参数来快速回收处于 TIME_WAIT 状态的连接，这两个参数都是默认关闭的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;net.ipv4.tcp_tw_reuse，如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，&lt;strong&gt;内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用&lt;/strong&gt;，所以该选项只适用于连接发起方。&lt;/li&gt;
&lt;li&gt;net.ipv4.tcp_tw_recycle，如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要使得这两个选项生效，有一个前提条件，就是要打开 &lt;strong&gt;TCP 时间戳&lt;/strong&gt;，即&lt;strong&gt;net.ipv4.tcp_timestamps=1&lt;/strong&gt;（默认即为 1）。&lt;/p&gt;
&lt;p&gt;但是，&lt;strong&gt;tcp_tw_recycle 在使用了 NAT 的网络下是不安全的！&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-dns协议和arp协议&#34;&gt;3. DNS协议和ARP协议
&lt;/h1&gt;&lt;p&gt;这两个协议都是用于&lt;strong&gt;地址间的转化&lt;/strong&gt;，起到了“翻译官”的职责。&lt;/p&gt;
&lt;h2 id=&#34;31-dns解析过程是什么&#34;&gt;3.1 DNS解析过程是什么？
&lt;/h2&gt;&lt;p&gt;DNS (Domain Name System) 是 &lt;strong&gt;域名系统&lt;/strong&gt; 的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统。&lt;/p&gt;
&lt;p&gt;它用于 TCP/IP 网络，它从事将&lt;strong&gt;主机名或域名转换为实际 IP 地址&lt;/strong&gt;的工作，类似于&lt;strong&gt;翻译官&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;DNS查询时优先考虑&lt;strong&gt;本地的Host文件&lt;/strong&gt;和&lt;strong&gt;本地的DNS解析器&lt;/strong&gt;是否保留有&lt;strong&gt;缓存映射&lt;/strong&gt;，如果没有就&lt;strong&gt;向上一级请求&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;依次按照&lt;strong&gt;DNS根服务器，DNS顶层服务器，DNS管理方服务器&lt;/strong&gt;的顺序请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200120162326.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;所谓&lt;strong&gt;递归查询就是变更查询者，迭代查询则没有变更。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-什么是mac地址&#34;&gt;3.2 什么是MAC地址？
&lt;/h2&gt;&lt;p&gt;MAC地址是数据链路层和物理层&lt;strong&gt;使用的地址（硬件地址）&lt;/strong&gt;，IP地址网络层和以上各层使用的地址，是一种&lt;strong&gt;逻辑地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在发送数据时，数据从高层到低层，然后才到通信链路上传输。&lt;strong&gt;使用IP地址的IP数据报一旦交给了数据链路层，就被封装成了MAC帧&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MAC帧在传送时使用的源地址和目的地址都是硬件地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216103838.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有了IP，为啥还需要MAC地址？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事实上，&lt;strong&gt;IP协议的产生并不只是为解决上述的“广播问题”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;还解决了很多其他网络传输过程会遇到的问题，&lt;strong&gt;比如一次传输的消息过大时，如何对消息进行分组等问题&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;由于历史原因，MAC 地址及相关技术先出现，但是后来发现它并不能解决所有（已知）的问题，所以，先驱们发明了 IP 地址及相关技术来解决。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一个角度，个人认为，&lt;strong&gt;由于 MAC 地址没有办法表达网络中的子网的概念，而 IP 地址可以&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果网络互换设备（比如路由器）能从目标 MAC 地址中分析出目标网络，而不是只是目标主机，IP 地址还会出现吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有另一个有趣的问题：**如果历史反过来，**一开始就使用的是 IP 地址，而不是 MAC 地址，我们现在的网络世界会怎么样？&lt;/p&gt;
&lt;h2 id=&#34;33-arp协议工作机制是什么&#34;&gt;3.3 ARP协议工作机制是什么？
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;ARP（Address Resolution Protocol）即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在每台安装有TCP/IP协议的&lt;strong&gt;电脑或路由器&lt;/strong&gt;里都有一个&lt;strong&gt;ARP缓存表&lt;/strong&gt;，&lt;strong&gt;表里的IP地址与MAC地址是一对应的&lt;/strong&gt;，如下表所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216104026.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;解析MAC地址时，主机A&lt;strong&gt;首先在其ARP高速缓存中&lt;/strong&gt;查找有无主机B的IP地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果没有就就向本地网段发起一个ARP请求的广播包&lt;/strong&gt;，&lt;strong&gt;查询此目的主机对应的MAC地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;网络中所有的主机收到这个&lt;strong&gt;ARP请求&lt;/strong&gt;后，会检查数据包中的目的IP是否和自己的IP地址一致。&lt;/p&gt;
&lt;p&gt;如果相同，该主机首先&lt;strong&gt;将发送端的MAC地址和IP地址添加到自己的ARP列表中&lt;/strong&gt;，如果ARP表中已经存在该IP的信息，&lt;strong&gt;则将其覆盖&lt;/strong&gt;，然后给源主机发送一个&lt;strong&gt;ARP响应数据包&lt;/strong&gt;，&lt;strong&gt;告诉对方自己是它需要查找的MAC地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;源主机收到后&lt;strong&gt;在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并且采用LRU机制，及时淘汰。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216104350.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查看 ARP 缓存内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Linux 系统中，&lt;strong&gt;我们可以使用 &lt;code&gt;arp -a&lt;/code&gt; 命令来查看 ARP 缓存的内容。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-http协议&#34;&gt;4. HTTP协议
&lt;/h1&gt;&lt;h2 id=&#34;41-http常见的请求方法和状态码&#34;&gt;4.1 HTTP常见的请求方法和状态码
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;OPTIONS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回服务器针对特定资源&lt;strong&gt;所支持的HTTP请求方法&lt;/strong&gt;，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HEAD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;向服务器索与GET请求相一致的响应，&lt;strong&gt;只不过响应体将不会被返回&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这一方法可以&lt;strong&gt;再不必传输整个响应内容的情况&lt;/strong&gt;下，就可以获取包&lt;strong&gt;含在响应小消息头中的元信息&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;向特定的资源发出请求&lt;/strong&gt;。注意：&lt;strong&gt;GET方法不应当被用于产生“副作用”的操作中&lt;/strong&gt;，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;POST&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;向指定资源提交数据进行处理请求&lt;/strong&gt;（例如提交表单或者上传文件）。&lt;/p&gt;
&lt;p&gt;数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;PUT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;向指定资源位置&lt;strong&gt;上传其最新内容&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DELETE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请求服务器&lt;strong&gt;删除Request-URL所标识的资源&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TRACE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回显服务器收到的请求&lt;/strong&gt;，主要用于&lt;strong&gt;测试或诊断&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CONNECT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）方法名称是&lt;strong&gt;区分大小写&lt;/strong&gt;的，当某个请求所针对的资源&lt;strong&gt;不支持对应的请求方法的时候，服务器应当返回状态码405&lt;/strong&gt;（Mothod Not Allowed）；&lt;/p&gt;
&lt;p&gt;当服务器&lt;strong&gt;不认识或者不支持对应的请求方法时，应返回状态码501&lt;/strong&gt;（Not Implemented）。&lt;/p&gt;
&lt;p&gt;2）HTTP服务器&lt;strong&gt;至少应该实现GET和HEAD/POST方法&lt;/strong&gt;，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持扩展自定义的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214133230.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;100 客户端必须继续发出请求  101 客户端要求服务器根据请求转换HTTP协议版本&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;200 交易成功 201 提示知道新文件的URL 202 接受和处理、但处理未完成&lt;/p&gt;
&lt;p&gt;203 返回信息不确定或不完整 204 请求收到，但返回信息为空&lt;/p&gt;
&lt;p&gt;205 服务器完成了请求，用户代理必须复位当前已经浏览过的文件 206 服务器已经完成了部分用户的GET请求&lt;/p&gt;
&lt;p&gt;300 请求的资源可在多处得到 301 永久重定向，在Location响应首部的值仍为当前URL(隐式重定向) 302 临时重定向，在Location响应首部的值仍为新的URL(显示重定向)&lt;/p&gt;
&lt;p&gt;303 建议客户端访问其他URL或访问方式 304 Not Modified 请求的资源没有改变 可以继续使用缓存 305 请求的资源必须从服务器指定的地址得到&lt;/p&gt;
&lt;p&gt;306 前一版本HTTP中使用的代码，现行版本中不再使用 307 声明请求的资源临时性删除&lt;/p&gt;
&lt;p&gt;400 错误请求，如语法错误 401 未授权402 保留有效ChargeTo头响应 403 禁止访问&lt;/p&gt;
&lt;p&gt;404 没有发现文件、查询或URL 405 用户在Request-Line字段定义的方法不允许&lt;/p&gt;
&lt;p&gt;406 根据用户发送的Accept拖，请求资源不可访问 407 类似401，用户必须首先在代理服务器上得到授权&lt;/p&gt;
&lt;p&gt;500 - 内部服务器错误 HTTP 500.100 - 内部服务器错误 HTTP 500-11 服务器关闭 HTTP&lt;/p&gt;
&lt;p&gt;500-12 应用程序重新启动 HTTP 500-13 - 服务器太忙 HTTP 500-14 - 应用程序无效 HTTP 500-15 - 不允许请求&lt;/p&gt;
&lt;p&gt;501 - 未实现   502 - 网关错误   503 - 服务不可用   504 - 网关超时。&lt;/p&gt;
&lt;h2 id=&#34;42-http协议和其他协议之间的关系&#34;&gt;4.2 HTTP协议和其他协议之间的关系
&lt;/h2&gt;&lt;p&gt;HTTP(超文本传输协议)是利用&lt;strong&gt;TCP在两台电脑(通常是Web服务器和客户端)之间传输信息&lt;/strong&gt;的协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果把TCP比作是高速路，HTTP就是卡车&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Socket是对TCP/IP协议的封装&lt;/strong&gt;，Socket本身并不是协议，而是一个&lt;strong&gt;调用接口（API Application Programming Interface,应用程序编程接口）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过Socket，我们能方便地使用TCP/IP协议。&lt;/p&gt;
&lt;h2 id=&#34;43-http长连接和短连接&#34;&gt;4.3 HTTP长连接和短连接
&lt;/h2&gt;&lt;p&gt;短连接：客户端和服务器&lt;strong&gt;每进行一次HTTP操作&lt;/strong&gt;，&lt;strong&gt;就建立一次连接，任务结束就中断连接&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;长连接：客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。&lt;strong&gt;有一个保持时间，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过Keep-Alive头字段, 服务器配置Nginx, 应用程序代码设置&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;44-http和https安全性端口证书url明密&#34;&gt;4.4 HTTP和HTTPS（安全性，端口，证书，URL，明密)
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTP 是超文本传输协议，信息是明文传输&lt;/strong&gt;，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层&lt;strong&gt;之间加入了 SSL/TLS 安全协议，使得报文能够加密传输&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 连接建立相对简单无状态的， TCP 三次握手之后便可进行 HTTP 的报文传输。&lt;/p&gt;
&lt;p&gt;而 HTTPS 在 TCP 三次握手之后，&lt;strong&gt;还需进行 SSL/TLS 的握手过程&lt;/strong&gt;，才可进入加密报文传输。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 的&lt;strong&gt;端口号是 80，HTTPS 的端口号是 443。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTTPS 协议需要向 CA（证书权威机构）申请数字证书&lt;/strong&gt;，来保证服务器的身份是可信的，一般免费证书较少，因而需要一定费用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HTTP：&lt;strong&gt;运行在TCP之上，明文传输&lt;/strong&gt;，客户端与服务器端都&lt;strong&gt;无法验证对方的身份。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTPS：&lt;strong&gt;Https是身披SSL&lt;/strong&gt;(Secure Socket Layer)外壳的Http，&lt;strong&gt;运行于SSL上&lt;/strong&gt;，&lt;strong&gt;SSL运行于TCP之上，是添加了加密和认证机制的HTTP。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;「&lt;strong&gt;HTTPS 是先进行 TCP 三次握手，再进行 TLS v1.2四次握手&lt;/strong&gt;」&lt;/p&gt;
&lt;p&gt;ps: 这句话一点问题都没有，怀疑这句话是错的人，才有问题。&lt;/p&gt;
&lt;p&gt;「&lt;strong&gt;HTTPS 中的 TLS 握手过程可以同时进行三次握手&lt;/strong&gt;」&lt;/p&gt;
&lt;p&gt;这个场景是可能存在到，但是在没有说任何前提条件，&lt;strong&gt;而说这句话就等于耍流氓。需要下面这两个条件同时满足才可以&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端和服务端已经完成过一次通信；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;441-https-是如何建立连接的其间交互了什么&#34;&gt;4.4.1 HTTPS 是如何建立连接的？其间交互了什么？
&lt;/h3&gt;&lt;p&gt;HTTPS 在HTTP的基础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。&lt;/p&gt;
&lt;p&gt;SSL/TLS 协议基本流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端向服务器索要并验证服务器的公钥。&lt;/li&gt;
&lt;li&gt;双方协商生产「会话秘钥」。&lt;/li&gt;
&lt;li&gt;双方采用「会话秘钥」进行加密通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://img-blog.csdn.net/20180920154005922?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HTTPS的缺点，虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（耗电，效率，证钱，IP，范围)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）HTTPS协议&lt;strong&gt;握手阶段比较费时&lt;/strong&gt;，会使页面的加载&lt;strong&gt;时间延长近50%，增加10%到20%的耗电&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;（2）HTTPS连接&lt;strong&gt;缓存不如HTTP高效&lt;/strong&gt;，会增加&lt;strong&gt;数据开销和功耗&lt;/strong&gt;，甚至已有的安全措施也会因此而受到影响；&lt;/p&gt;
&lt;p&gt;（3）&lt;strong&gt;SSL证书需要钱&lt;/strong&gt;，&lt;strong&gt;功能越强大的证书费用越高&lt;/strong&gt;，个人网站、小网站没有必要一般不会用。&lt;/p&gt;
&lt;p&gt;（4）&lt;strong&gt;SSL证书通常需要绑定IP&lt;/strong&gt;，&lt;strong&gt;不能在同一IP上绑定多个域名&lt;/strong&gt;，IPv4资源不可能支撑这个消耗。&lt;/p&gt;
&lt;p&gt;（5）HTTPS协议的&lt;strong&gt;加密范围也比较有限&lt;/strong&gt;，在黑客攻击、&lt;strong&gt;拒绝服务攻击、服务器劫持&lt;/strong&gt;等方面几乎起不到什么作用。&lt;/p&gt;
&lt;p&gt;最关键的，&lt;strong&gt;SSL证书的信用链体系并不安全&lt;/strong&gt;，特别是在&lt;strong&gt;某些国家可以控制CA根证书的情况&lt;/strong&gt;下，中间人攻击一样可行。&lt;/p&gt;
&lt;h2 id=&#34;45-get和post的区别&#34;&gt;4.5 GET和POST的区别
&lt;/h2&gt;&lt;p&gt;GET和POST本质上就是TCP链接，并无差别。但是由于&lt;strong&gt;HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;GET在浏览器&lt;strong&gt;回退或者刷新时时无害的&lt;/strong&gt;，而POST会再次提交请求，因为GET请求&lt;strong&gt;是安全幂等&lt;/strong&gt;的，而POST不是&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GET&lt;strong&gt;参数通过URL传递&lt;/strong&gt;，&lt;strong&gt;POST放在Request body中&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GET请求在URL中&lt;strong&gt;传送的参数是有长度限制的；&lt;strong&gt;而POST没有，因为大多数浏览器通常都会&lt;/strong&gt;限制url长度在2K个字节&lt;/strong&gt;，而大多数服务器&lt;strong&gt;最多处理64K大小的url&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GET请求只能进行&lt;strong&gt;url编码&lt;/strong&gt;，而POST&lt;strong&gt;支持多种编码方式，form， json， xml&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对&lt;strong&gt;参数的数据类型，GET只接受ASCII字符&lt;/strong&gt;，&lt;strong&gt;而POST没有限制&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GET比POST更不安全，&lt;strong&gt;因为参数直接暴露在URL上，所以不能用来传递敏感信息&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GET请&lt;strong&gt;求参数会被完整保留在浏览器历史记录里，可被收藏为书签&lt;/strong&gt;，&lt;strong&gt;而POST中的参数不会被保留&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GET&lt;strong&gt;请求会被浏览器主动cache&lt;/strong&gt;，而POST不会，除非手动设置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GET产生一个TCP数据包；POST产生两个TCP数据包。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；&lt;/p&gt;
&lt;p&gt;而对于POST，&lt;strong&gt;浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok&lt;/strong&gt;（返回数据）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;做数据查询时，建议用Get方式&lt;/strong&gt;；  而&lt;strong&gt;在做数据添加、修改或删除时，建议用Post方式&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;安全的是指没有明显的对用户有影响的副作用(包括修改该资源的状态)仅指该方法的多次调用不会产生副作用，不涉及传统意义上的“安全”，这里的副作用是指资源状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即，安全的方法不会修改资源状态&lt;/strong&gt;，尽管多次调用的返回值可能不一样(被其他非安全方法修改过)。HTTP方法里的GET和HEAD都是安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;幂等&lt;/strong&gt;指的是&lt;strong&gt;一个方法不论多少次操作，结果都是一样&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;**PUT(把内容放到指定URL)，**DELETE(&lt;strong&gt;删除某个URL代表的资源)&lt;/strong&gt;，虽然都修改了资源内容，但多次操作，结果是相同的，&lt;strong&gt;因此和HEAD，GET一样都是幂等的。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;46-cookie和session的区别&#34;&gt;4.6 Cookie和Session的区别
&lt;/h2&gt;&lt;p&gt;Cookie和Session都是客户端与服务器之间保持状态的解决方案&lt;/p&gt;
&lt;p&gt;具体来说，&lt;strong&gt;cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cookie实际上是&lt;strong&gt;一小段文本信息&lt;/strong&gt;。客户端请求服务器，如果服务器需要记录该用户状态，就向客户端浏览器&lt;strong&gt;颁发一个Cookie&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端浏览器会把Cookie保存起来&lt;/strong&gt;。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cookie对象使用key-value属性对的形式保存用户状态&lt;/strong&gt;，一个Cookie对象保存一个属性对。&lt;/p&gt;
&lt;p&gt;一个request或者response同时使用多个Cookie。&lt;/p&gt;
&lt;p&gt;因为Cookie类位于包javax.servlet.http.*下面，所以JSP中不需要import该类。每个属性对应一个getter方法与一个setter方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cookie并不提供修改、删除操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/66f870bb-756b-458e-b92b-9ef1473d77c6/Untitled.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Untitled&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;Session的区别在于，&lt;strong&gt;会话状态完全保存在服务器&lt;/strong&gt;。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session就按照sessionid把这个session检索出来使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器Session常常依赖于Cookie机制检索ID。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但Cookie被禁用时也有其他方法比如URL重写机制&lt;/strong&gt;，使用上比Cookie简单一些，相应的也&lt;strong&gt;增加了服务器的存储压力&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Session对应的类为javax.servlet.http.HttpSession类。每个来访者对应一个Session对象，&lt;strong&gt;所有该客户的状态信息都保存在这个Session对象里&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Session对象是在客户端第一次请求服务器的时候创建的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Session也是一种key-value的属性对，通过getAttribute(Stringkey)和setAttribute(String key，Objectvalue)方法读写客户状态信息。Servlet里通过request.getSession()方法获取该客户的Session，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了获得更高的存取速度，服务器一般把Session放在内存里。每个用户都会有一个独立的Session。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，Session里的信息应该尽量精简。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于会有越来越多的用户访问服务器，因此Session也会越来越多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它的正常运行仍然需要客户端浏览器的支持。这是因为Session需要使用Cookie作为识别标志。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP协议是无状态的&lt;/strong&gt;，Session不能依据HTTP连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为&lt;strong&gt;JSESSIONID的Cookie&lt;/strong&gt;，&lt;strong&gt;它的值为该Session的id（也就是HttpSession.getId()的返回值）。Session依据该Cookie来识别是否为同一用户。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该Cookie为服务器自动生成的&lt;/strong&gt;，它的&lt;strong&gt;maxAge属性一般为–1，表示仅当前浏览器内有效&lt;/strong&gt;，并且&lt;strong&gt;各浏览器窗口间不共享&lt;/strong&gt;，关闭浏览器就会失效。&lt;/p&gt;
&lt;p&gt;因此同一机器的两个浏览器窗口访问服务器时，&lt;strong&gt;会生成两个不同的Session&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;但是由浏览器窗口内的链接、脚本等打开的新窗口（也就是说不是双击桌面浏览器图标等打开的窗口）除外。&lt;strong&gt;这类子窗口会共享父窗口的Cookie，因此会共享一个Session&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URL地址重写是对客户端不支持Cookie的解决方案&lt;/strong&gt;。&lt;strong&gt;URL地址重写的原理是将该用户Session的id信息重写到URL地址中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。&lt;/p&gt;
&lt;h2 id=&#34;47-http请求报文和响应报文的格式&#34;&gt;4.7 HTTP请求报文和响应报文的格式
&lt;/h2&gt;&lt;p&gt;请求报文格式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求行（&lt;strong&gt;请求方法+URI协议+版本&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;请求头部&lt;/li&gt;
&lt;li&gt;空行&lt;/li&gt;
&lt;li&gt;请求主体&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;GET/sample.jsp HTTP/1.1 请求行
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Accept:image/gif.image/jpeg, 请求头部
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Accept-Language:zh-cn
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Connection:Keep-Alive
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Host:localhost
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Accept-Encoding:gzip,deflate
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;username=jinqiao&amp;amp;password=1234 请求主体
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;响应报文：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;状态行（版本+状态码+原因短语）&lt;/li&gt;
&lt;li&gt;响应首部&lt;/li&gt;
&lt;li&gt;空行&lt;/li&gt;
&lt;li&gt;响应主体&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HTTP/1.1 200 OK
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Server:Apache Tomcat/5.0.12
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Date:Mon,6Oct2003 13:23:42 GMT
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Content-Length:112
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;head&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &amp;lt;title&amp;gt;HTTP响应示例&amp;lt;title&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;/head&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;body&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Hello HTTP!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &amp;lt;/body&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;48-http11http2http3-演变&#34;&gt;4.8 HTTP/1.1、HTTP/2、HTTP/3 演变
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP/1.1 相比 HTTP/1.0 性能上的改进：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(长连接，管道网络)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持管道（pipeline）网络传输&lt;/strong&gt;，只要第一个请求发出去了，&lt;strong&gt;不必等其回来，就可以发第二个请求出去&lt;/strong&gt;，可以&lt;strong&gt;减少整体的响应时间&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但 HTTP/1.1 还是有性能瓶颈：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(头部未压缩，相同首部浪费，依然有响应的队头阻塞，无请求优先级，服务器只能被动响应)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;请求 / 响应头部（Header）未经压缩就发送&lt;/strong&gt;，首部信息越多延迟越大。只能压缩 &lt;code&gt;Body&lt;/code&gt; 的部分；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发送冗长的首部。每次互相发送相同的首部造成的浪费较多&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务器是按请求的顺序响应的&lt;/strong&gt;，&lt;strong&gt;如果服务器响应慢，会导致客户端一直请求不到数据&lt;/strong&gt;，&lt;strong&gt;也就是响应的队头阻塞&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;没有请求优先级控制&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;请求只能从客户端开始，服务器只能被动响应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP/2 相比 HTTP/1.1 性能上的改进：&lt;/p&gt;
&lt;p&gt;HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(双向数据流（同一连接并行请求响应)，资源处理优先级，服务器推送，压缩头部二进制）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以使用&lt;strong&gt;同一个连接并行发送多个请求和相应&lt;/strong&gt;，&lt;strong&gt;可以承接双向数据流&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;允许设定数据流中不同资源的&lt;strong&gt;优先级&lt;/strong&gt;，&lt;strong&gt;明确资源处理的先后顺序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;打破了&lt;strong&gt;请求-响应的束缚&lt;/strong&gt;，除了最初的请求响应外，&lt;strong&gt;服务器还能向客户端推送额外的资源&lt;/strong&gt;（客户端没有明确要求的情况下）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;压缩头部，头信息和数据体都是二进制格式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;1. 头部压缩&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;HTTP/2 会&lt;strong&gt;压缩头&lt;/strong&gt;（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你&lt;strong&gt;消除重复的部分&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这就是所谓的 &lt;strong&gt;&lt;code&gt;HPACK&lt;/code&gt; 算法&lt;/strong&gt;：在客户端和服务器同时&lt;strong&gt;维护一张头信息表&lt;/strong&gt;，所有&lt;strong&gt;字段都会存入这个表&lt;/strong&gt;，&lt;strong&gt;生成一个索引号&lt;/strong&gt;，以后就不发送同样字段了，只发送索引号，这样就&lt;strong&gt;提高速度&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;2. 二进制格式&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了&lt;strong&gt;二进制格式&lt;/strong&gt;，头信息和数据体都是二进制，并且统称为帧（frame）：&lt;strong&gt;头信息帧（Headers Frame）和数据帧（Data Frame）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http2/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，&lt;strong&gt;那么收到报文后，无需再将明文的报文转成二进制&lt;/strong&gt;，&lt;strong&gt;而是直接解析二进制报文&lt;/strong&gt;，这&lt;strong&gt;增加了数据传输的效率&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是&lt;strong&gt;没有解决响应的队头阻塞&lt;/strong&gt;，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等相应完这个请求后， 才能处理下一个请求，&lt;strong&gt;这属于 HTTP 层队头阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP/2 虽然通过&lt;strong&gt;多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞&lt;/strong&gt; ，&lt;strong&gt;但是一旦发生丢包，就会阻塞住所有的 HTTP 请求&lt;/strong&gt;，&lt;strong&gt;这属于 TCP 层队头阻塞。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/25-HTTP2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;HTT/1 ~ HTTP/2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP/2 &lt;strong&gt;队头阻塞的问题是因为 TCP&lt;/strong&gt;，所以 &lt;strong&gt;HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/27-HTTP3.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;HTTP/1 ~ HTTP/3&lt;/p&gt;
&lt;p&gt;UDP 发生是&lt;strong&gt;不管顺序，也不管丢包&lt;/strong&gt;的，所以&lt;strong&gt;不会出现像 HTTP/2 队头阻塞的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大家都知道 UDP 是不可靠传输的，但基于 UDP 的 &lt;strong&gt;QUIC 协议&lt;/strong&gt; 可以实现类似 &lt;strong&gt;TCP 的可靠性传输。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;49-如何减少-http-请求次数&#34;&gt;4.9 如何减少 HTTP 请求次数？
&lt;/h2&gt;&lt;p&gt;减少 HTTP 请求次数自然也就提升了 HTTP 性能，可以从这 3 个方面入手：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（&lt;em&gt;减少重定向请求次数，合并请求，延迟发送请求）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;减少重定向请求次数&lt;/em&gt;；服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，而是通过 &lt;code&gt;302&lt;/code&gt; 响应码和 &lt;code&gt;Location&lt;/code&gt; 头部，告诉客户端该资源已经迁移至 url2 了&lt;/strong&gt;，于是客户端需要再发送 url2 请求以获得服务器的资源。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;合并请求&lt;/strong&gt;&lt;/em&gt;；如果把&lt;strong&gt;多个访问小文件的请求合并成一个大的请求&lt;/strong&gt;，虽然传输的总资源还是一样，但是减少请求，也就意味着&lt;strong&gt;减少了重复发送的 HTTP 头部&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;延迟发送请求&lt;/em&gt;；请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源&lt;/strong&gt;，这样就达到了延迟发送请求的效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;410-如何减少-http-响应的数据大小&#34;&gt;4.10 如何减少 HTTP 响应的数据大小？
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;（有损无损压缩，质量因子）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以考虑对响应的资源进行&lt;strong&gt;压缩&lt;/strong&gt;，这样就可以减少响应的数据大小，从而提高网络传输的效率。&lt;/p&gt;
&lt;p&gt;压缩的方式一般分为 2 种，分别是：&lt;strong&gt;&lt;em&gt;无损压缩&lt;/em&gt;；&lt;em&gt;有损压缩&lt;/em&gt;；&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;无损压缩&#34;&gt;无损压缩
&lt;/h3&gt;&lt;p&gt;无损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，&lt;strong&gt;适合用在文本文件、程序可执行文件、程序源代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;gzip 就是比较常见的无损压缩&lt;/strong&gt;。（客户端支持的压缩算法，会在 HTTP 请求中通过头部中的 &lt;code&gt;Accept-Encoding&lt;/code&gt; 字段告诉服务器）&lt;/p&gt;
&lt;h3 id=&#34;有损压缩&#34;&gt;有损压缩
&lt;/h3&gt;&lt;p&gt;与无损压缩相对的就是有损压缩，经过此方法压缩，&lt;strong&gt;解压的数据会与原始数据不同但是非常接近&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有损压缩主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，这种方法经常用于压缩多媒体数据，比如&lt;strong&gt;音频、视频、图片。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过 HTTP 请求头部中的 &lt;code&gt;Accept&lt;/code&gt; 字段里的「 &lt;strong&gt;q 质量因子&lt;/strong&gt;」，告诉服务器期望的资源质量。&lt;/p&gt;
&lt;p&gt;关于图片的压缩，&lt;strong&gt;目前压缩比较高的是 Google 推出的 WebP 格式&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;411-http如何优化&#34;&gt;4.11 Http如何优化
&lt;/h2&gt;&lt;p&gt;对于硬件优化的方向，因为 HTTPS 是属于&lt;strong&gt;计算密集型，应该选择计算力更强的 CPU&lt;/strong&gt;，而且最好选择&lt;strong&gt;支持 AES-NI 特性的 CPU&lt;/strong&gt;，这个特性可以在硬件级别&lt;strong&gt;优化 AES 对称加密算法&lt;/strong&gt;，加快应用数据的加解密。&lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;软件优化&lt;/strong&gt;的方向，如果可以，把软件升级成较新的版本，比如将 &lt;strong&gt;Linux 内核 2.X 升级成 4.X&lt;/strong&gt;，将 &lt;strong&gt;openssl 1.0.1 升级到 1.1.1&lt;/strong&gt;，因为新版本的软件不仅会提供新的特性，而且还会修复老版本的问题。&lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;协议优化&lt;/strong&gt;的方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;密钥交换算法应该选择 &lt;strong&gt;ECDHE 算法&lt;/strong&gt;，而不用 RSA 算法，因为 ECDHE 算法具备前向安全性，而且客户端可以在第三次握手之后，就发送加密应用数据，节省了 1 RTT。&lt;/li&gt;
&lt;li&gt;将 TSL1.2 升级 &lt;strong&gt;TSL1.3&lt;/strong&gt;，因为 &lt;strong&gt;TSL1.3 的握手过程只需要 1 RTT&lt;/strong&gt;，而且安全性更强。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于&lt;strong&gt;证书优化&lt;/strong&gt;的方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器应该选用 &lt;strong&gt;ECDSA 证书&lt;/strong&gt;，而非 RSA 证书，因为在相同安全级别下，&lt;strong&gt;ECC 的密钥长度比 RSA 短很多&lt;/strong&gt;，这样可以提高证书传输的效率；&lt;/li&gt;
&lt;li&gt;服务器应该开启 &lt;strong&gt;OCSP Stapling&lt;/strong&gt; 功能，由服务器预先获得 OCSP 的响应，并把响应结果缓存起来，这样 TLS 握手的时候就不用再访问 CA 服务器，减少了网络通信的开销，提高了证书验证的效率；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于&lt;strong&gt;重连 HTTPS 时，我们可以使用一些技术让客户端和服务端使用上一次 HTTPS 连接使用的会话密钥&lt;/strong&gt;，直接恢复会话，而不用再重新走完整的 TLS 握手过程。&lt;/p&gt;
&lt;p&gt;常见的&lt;strong&gt;会话重用&lt;/strong&gt;技术有 &lt;strong&gt;Session ID 和 Session Ticket，用了会话重用技术，当再次重连 HTTPS 时，只需要 1 RTT 就可以恢复会话&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于 TLS1.3 使用 Pre-shared Key 会话重用技术，只需要 0 RTT 就可以恢复会话。这些&lt;strong&gt;会话重用技术虽然好用，但是存在一定的安全风险，它们不仅不具备前向安全&lt;/strong&gt;，而且有&lt;strong&gt;重放攻击的风险&lt;/strong&gt;，所以应当对会话密钥设定一个合理的过期时间。&lt;/p&gt;
&lt;h2 id=&#34;412-hsts协议&#34;&gt;4.12 HSTS协议
&lt;/h2&gt;&lt;p&gt;HSTS（HTTP Strict Transport Security）是一种安全协议，旨在增强网站的安全性，特别是针对HTTPS连接。H&lt;strong&gt;STS通过强制客户端（如浏览器）只能通过加密连接（HTTPS）与服务器通信来防止中间人攻击和SSL剥离攻击。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HSTS的工作原理是在服务器的响应头中包含一个特殊的&lt;strong&gt;HTTP头部字段（Strict-Transport-Security），该字段告知浏览器在未来一段时间内（例如一年）只能通过HTTPS连接访问该网站&lt;/strong&gt;。一旦浏览器接收到这个头部字段，它将会记住并在接下来的请求中自动使用HTTPS连接。&lt;/p&gt;
&lt;p&gt;使用HSTS可以有效减少网站受到中间人攻击和SSL剥离攻击的风险，提高网站的安全性。&lt;/p&gt;
&lt;h1 id=&#34;5-ip地址&#34;&gt;5. IP地址
&lt;/h1&gt;&lt;h2 id=&#34;51-ip地址的格式是什么&#34;&gt;5.1 IP地址的格式是什么？
&lt;/h2&gt;&lt;p&gt;什么是IP地址？IP协议提供的一种统一的地址格式，&lt;strong&gt;它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。&lt;/p&gt;
&lt;p&gt;每个IP地址包括两个标识码（ID）：&lt;strong&gt;网络ID和主机ID。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。3字节的网络地址 + 1字节主机地址的意思就是：前三段号码为网络号码，剩下的一段号码为本地计算机的号码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;A类地址&lt;/strong&gt;：1字节的网络地址 + 3字节主机地址，&lt;strong&gt;网络地址的最高位必须是0&lt;/strong&gt;。A类IP地址的地址范围&lt;strong&gt;1.0.0.0到127.255.255.255&lt;/strong&gt;，IP地址的子网掩码为255.0.0.0，&lt;strong&gt;每个网络支持的最大主机数为&lt;/strong&gt;&lt;code&gt;256^3-2&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;B类地址&lt;/strong&gt;：2字节的网络地址 + 2字节主机地址，&lt;strong&gt;网络地址的最高位必须是10&lt;/strong&gt;。B类IP地址地址范围**128.0.0.0-191.255.255.255，**B类IP地址的子网掩码为255.255.0.0，&lt;strong&gt;每个网络支持的最大主机数&lt;/strong&gt;为&lt;code&gt;256^2-2&lt;/code&gt;。注：1000 0000=128&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;C类地址&lt;/strong&gt;：3字节的网络地址 + 1字节主机地址，&lt;strong&gt;网络地址的最高位必须是110&lt;/strong&gt;。C类IP地址范围**192.0.0.0-223.255.255.255。**每个网络支持的最大主机数为&lt;code&gt;256-2&lt;/code&gt;。&lt;strong&gt;适用于小规模局域网络&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;D类地址：&lt;strong&gt;多播地址，用于1对多通信，&lt;strong&gt;最高位必须是1110&lt;/strong&gt;。范围从&lt;/strong&gt;224.0.0.0到239.255.255.255&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;E类地址&lt;/strong&gt;:：为保留地址，&lt;strong&gt;最高位必须是“11110”&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;IPv4 首部与 IPv6 首部&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;IPv4 首部与 IPv6 首部的差异如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/31.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;IPv6 相比 IPv4 的首部改进：&lt;/p&gt;
&lt;p&gt;(&lt;strong&gt;取消了首部校验和字段, 取消了中间路由分片/重新组装相关字段，取消选项字段）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;取消了首部校验和字段。&lt;/strong&gt; 因为&lt;strong&gt;在数据链路层和传输层都会校验&lt;/strong&gt;，因此 &lt;strong&gt;IPv6 直接取消了 IP 的校验。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;取消了分片/重新组装相关字段。&lt;/strong&gt; 分片与重组是耗时的过程，&lt;strong&gt;IPv6 不允许在中间路由器进行分片与重组&lt;/strong&gt;，&lt;strong&gt;这种操作只能在源与目标主机&lt;/strong&gt;，&lt;strong&gt;这将大大提高了路由器转发的速度。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;取消选项字段。&lt;/strong&gt; &lt;strong&gt;选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上&lt;/strong&gt;。删除该选项字段使的 IPv6 的首部成为固定长度的 &lt;code&gt;40&lt;/code&gt; 字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;52-单播广播多播的区别是什么&#34;&gt;5.2 单播广播多播的区别是什么？
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;单播：主机间一对一通信&lt;/strong&gt;。   优点：&lt;strong&gt;个性化服务，及时响应&lt;/strong&gt;；缺点：&lt;strong&gt;流量压力大&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;广播：主机间一对所有通信&lt;/strong&gt;。优点：布局简单，维护方便，&lt;strong&gt;流量负载低&lt;/strong&gt;。缺点：&lt;strong&gt;缺乏个性化服务&lt;/strong&gt;，无法在Internet宽带上传播。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多播（组播）：主机间一对一组通信&lt;/strong&gt;。优点：&lt;strong&gt;兼具流量负载和个性化的优点&lt;/strong&gt;，允许在Internet宽带上传播。缺点：&lt;strong&gt;与单播协议相比没有纠错机制&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;53-如何划分子网&#34;&gt;5.3 如何划分子网？
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;划分子网的方法是从主机号借用若干个位作为子网号&lt;/strong&gt;，&lt;strong&gt;而主机号也就相应减少了若干个位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;于是两级IP地址在本单位内部就变为三级IP地址：&lt;strong&gt;网络号、子网号和主机号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;区分子网号和主机号的办法是：通过&lt;strong&gt;子网掩码&lt;/strong&gt;将&lt;strong&gt;网络号和子网号全设为1&lt;/strong&gt;的IP地址为子网掩码。&lt;/p&gt;
&lt;p&gt;假设公司有4个部门，A部门有10台主机，B部门有15台主机，C部门有30台主机，D部门有20台主机。分配了一个总的网段为：192.168.2.0/24。请问该如何划分子网？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网段前面的数字是我们的网络地址，后面的24表示用24位来表示网络位，用32-24=8位来表示主机位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;主机数目不多，可以小型组网，因此&lt;strong&gt;采用C类地址(最大254个主机)，默认掩码为225.255.255.0。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先假设借用主机位&lt;strong&gt;2位来划分4个子网&lt;/strong&gt;，则子网掩码组合为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11111111.11111111.11111111.00 000000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11111111.11111111.11111111.01 000000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11111111.11111111.11111111.10 000000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11111111.11111111.11111111.11 000000
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;然而全为0和全为1的地址不能用&lt;/strong&gt;，所以我们需要借用主机位3位，划分&lt;code&gt;8-2=6&lt;/code&gt;个子网：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11111111.11111111.11111111.00100000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11111111.11111111.11111111.01000000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11111111.11111111.11111111.01100000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11111111.11111111.11111111.10000000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11111111.11111111.11111111.10100000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11111111.11111111.11111111.11000000
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;验证一下：最后提供的主机位数是&lt;code&gt;2^5=32&lt;/code&gt;，也就是说每个子网&lt;strong&gt;最大的主机数是32-2=30&lt;/strong&gt;，符合题目要求。所以子网划分如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;（1）255.255.255.32:    192.168.2.33~ 192.168.2.62
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;（2）255.255.255.64:   192.168.2.65~ 192.168.2.94
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;（3）255.255.255.96:   192.168.2.97~ 192.168.2.126
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;（4）255.255.255.128:  192.168.2.129~ 192.168.2.158
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;（5）255.255.255.160:  192.168.2.161~ 192.168.2.190
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;（6）255.255.255.192:  192.168.2.193~ 192.168.2.222
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;子网掩码是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;11111111.11111111.11111111.111 00000
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;255.255.255.224
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;6-网络安全&#34;&gt;6. 网络安全
&lt;/h1&gt;&lt;h2 id=&#34;61-什么是ddos攻击&#34;&gt;6.1 什么是DDos攻击？
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;DDos全称Distributed Denial of Service&lt;/strong&gt;，&lt;strong&gt;分布式拒绝服务攻击&lt;/strong&gt;。最基本的DOS攻击过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端向服务端发送请求链接数据包&lt;/li&gt;
&lt;li&gt;服务端向客户端发送确认数据包&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DDoS则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。&lt;/p&gt;
&lt;p&gt;DOS攻击现在基本没啥作用了，因为&lt;strong&gt;服务器的性能都很好&lt;/strong&gt;，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于DDOS攻击，预防方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;减少SYN timeout时间。&lt;strong&gt;在&lt;/strong&gt;握手的第三步&lt;/strong&gt;，&lt;strong&gt;服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;限制同时打开的SYN半连接数目。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;62-什么是xss攻击&#34;&gt;6.2 什么是XSS攻击？
&lt;/h2&gt;&lt;p&gt;XSS也称 cross-site scripting，&lt;strong&gt;跨站脚本&lt;/strong&gt;。攻击者在web页面中会&lt;strong&gt;插入一些恶意的script代码&lt;/strong&gt;。当用户浏览该页面的时候，&lt;strong&gt;那么嵌入到web页面中script代码会执行&lt;/strong&gt;，因此会达到恶意攻击用户的目的。&lt;/p&gt;
&lt;p&gt;那么XSS攻击最主要有如下分类：&lt;strong&gt;反射型、存储型、及 DOM-based型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反射性和DOM-baseed型可以归类为非持久性XSS攻击，存储型可以归类为持久性XSS攻击。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如一个存在XSS漏洞的&lt;strong&gt;论坛，用户发帖时&lt;/strong&gt;就可以引入&lt;strong&gt;带有＜script＞标签的代码&lt;/strong&gt;，导致恶意代码的执行。&lt;/p&gt;
&lt;p&gt;预防措施有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端：&lt;strong&gt;过滤&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;后端：&lt;strong&gt;转义，比如go自带的处理器就具有转义功能。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反射性xss一般指攻击者通过特定的方式来&lt;strong&gt;诱惑受害者去访问一个包含恶意代码的URL&lt;/strong&gt;。当受害者点击恶意链接url的时候，&lt;strong&gt;恶意代码会直接在受害者的主机上的浏览器执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存储型XSS的原理是：&lt;strong&gt;主要是&lt;/strong&gt;将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;63-什么是注入sql攻击&#34;&gt;6.3 什么是注入SQL攻击？
&lt;/h2&gt;&lt;p&gt;XSS是将脚本代码注入，而SQL注入攻击顾名思义就是注入SQL语句。&lt;/p&gt;
&lt;p&gt;SQL注入是通过客户端的输入把SQL命令注入到一个应用的数据库中，从而执行恶意的SQL语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果通过参数进行拼接，拼接后的sql语句&lt;/strong&gt;就是： &lt;strong&gt;select * from user where username = ’’ and password = ’ ’ or ‘123’ = ‘123’;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样的了，那么会有一个or语句，只要这两个有一个是正确的话，就条件成立，因此 123 = 123 是成立的。因此验证就会被跳过。&lt;/p&gt;
&lt;p&gt;这只是一个简单的列子，比如还有密码比如是这样的：’; drop table user;, 这样的话，那么sql命令就变成了：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;select * from user where username = ’’ and password = ’‘; drop table user;’ , 那么这个时候我们会把user表直接删除了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;username&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Form&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;username&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Form&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;password&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;SELECT * FROM user WHERE username=&amp;#39;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;username&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#39; AND password=&amp;#39;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#39;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当用户输入&lt;code&gt;myuser&#39; or &#39;foo&#39; = &#39;foo&#39; --&lt;/code&gt;，那么SQL就变成了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;SELECT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;FROM&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;WHERE&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;username&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;myuser&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;or&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;AND&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;xxx&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在SQL里面&lt;code&gt;--&lt;/code&gt;是注释标记，所以查询语句会在此中断。&lt;/p&gt;
&lt;p&gt;这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;预防方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;限制数据库权限&lt;/strong&gt;，给用户提供仅仅能够满足其工作的最低权限。&lt;/li&gt;
&lt;li&gt;对进入数据库的&lt;strong&gt;特殊字符（’”&amp;amp;*;等）转义处理&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供参数化查询接口&lt;/strong&gt;，&lt;strong&gt;不要直接使用原生SQL&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;永远&lt;strong&gt;不要信任用户的输入&lt;/strong&gt;。对用户的输入进行校验，可以通过正&lt;strong&gt;则表达式&lt;/strong&gt;，或限制长度；对&lt;strong&gt;单引号和 双“-”进行转换&lt;/strong&gt;等。&lt;/li&gt;
&lt;li&gt;永远&lt;strong&gt;不要使用动态拼装sql&lt;/strong&gt;，可以使用&lt;strong&gt;参数化的sql&lt;/strong&gt;或者&lt;strong&gt;直接使用存储过程进行数据查询存取&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;永远&lt;strong&gt;不要使用管理员权限的数据库连接&lt;/strong&gt;，为&lt;strong&gt;每个应用使用单独的权限有限的数据库连接。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;不要把&lt;strong&gt;机密信息直接存放&lt;/strong&gt;，加密或者&lt;strong&gt;hash掉密码和敏感&lt;/strong&gt;的信息。&lt;/li&gt;
&lt;li&gt;应用的异&lt;strong&gt;常信息应该给出尽可能少的提示&lt;/strong&gt;，最好使&lt;strong&gt;用自定义的错误信息对原始错误信息进行包装&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sql注入的检测方法一般采取辅助软件或网站平台来检测&lt;/strong&gt;，软件一般采用sql注入检测工具&lt;strong&gt;jsky&lt;/strong&gt;，网站平台就有&lt;strong&gt;亿思网站&lt;/strong&gt;安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
